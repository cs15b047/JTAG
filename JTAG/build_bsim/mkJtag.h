/*
 * Generated by Bluespec Compiler, version 2017.03.beta1 (build 35049, 2017-03-16)
 * 
 * On Sun Jun 18 11:21:19 IST 2017
 * 
 */

/* Generation options: keep-fires */
#ifndef __mkJtag_h__
#define __mkJtag_h__

#include "bluesim_types.h"
#include "bs_module.h"
#include "bluesim_primitives.h"
#include "bs_vcd.h"


/* Class declaration for the mkJtag module */
class MOD_mkJtag : public Module {
 
 /* Clock handles */
 private:
  tClock __clk_handle_0;
  tClock __clk_handle_1;
 
 /* Clock gate handles */
 public:
  tUInt8 *clk_gate[0];
 
 /* Instantiation parameters */
 public:
 
 /* Module state */
 public:
  MOD_Reg<tUInt8> INST_bypass;
  MOD_Reg<tUInt8> INST_bypass_select;
  MOD_Reg<tUInt8> INST_bypass_tdo;
  MOD_Reg<tUInt8> INST_capture_dr;
  MOD_Reg<tUInt8> INST_capture_ir;
  MOD_Reg<tUInt8> INST_count;
  MOD_Reg<tUInt8> INST_debug_op;
  MOD_Reg<tUInt8> INST_debug_select;
  MOD_Reg<tUInt8> INST_exit1_dr;
  MOD_Reg<tUInt8> INST_exit1_ir;
  MOD_Reg<tUInt8> INST_exit2_dr;
  MOD_Reg<tUInt8> INST_exit2_ir;
  MOD_Reg<tUInt8> INST_extest_select;
  MOD_Reg<tUInt32> INST_idcode;
  MOD_Reg<tUInt8> INST_idcode_select;
  MOD_Reg<tUInt8> INST_idcode_tdo;
  MOD_Reg<tUInt8> INST_instr_tdo;
  MOD_Reg<tUInt8> INST_instruction;
  MOD_Reg<tUInt8> INST_instruction2;
  MOD_Reg<tUInt8> INST_instruction3;
  MOD_ClockInverter INST_inverted;
  MOD_Reg<tUInt8> INST_latch_ir;
  MOD_Reg<tUInt8> INST_latch_ir_neg;
  MOD_Reg<tUInt8> INST_pause_dr;
  MOD_Reg<tUInt8> INST_pause_ir;
  MOD_Reg<tUInt8> INST_run_test_idle;
  MOD_Reg<tUInt8> INST_sample_preload_select;
  MOD_Reg<tUInt8> INST_scan_chain_op;
  MOD_Reg<tUInt8> INST_select_dr_scan;
  MOD_Reg<tUInt8> INST_select_ir_scan;
  MOD_Reg<tUInt8> INST_shift_dr;
  MOD_Reg<tUInt8> INST_shift_ir;
  MOD_Reg<tUInt8> INST_shift_ir_neg;
  MOD_Reg<tUInt8> INST_tdi;
  MOD_Reg<tUInt8> INST_tdo;
  MOD_Reg<tUInt8> INST_tdo_enable;
  MOD_Reg<tUInt8> INST_test_logic_reset;
  MOD_Reg<tUInt8> INST_tms;
  MOD_Reg<tUInt32> INST_tms_vec;
  MOD_Reg<tUInt8> INST_update_dr;
  MOD_Reg<tUInt8> INST_update_ir;
 
 /* Constructor */
 public:
  MOD_mkJtag(tSimStateHdl simHdl, char const *name, Module *parent);
 
 /* Symbol init methods */
 private:
  void init_symbols_0();
 
 /* Reset signal definitions */
 private:
  tUInt8 PORT_RST_N;
 
 /* Port definitions */
 public:
 
 /* Publicly accessible definitions */
 public:
  tUInt8 DEF_WILL_FIRE___me_check_14;
  tUInt8 DEF_CAN_FIRE___me_check_14;
  tUInt8 DEF_WILL_FIRE___me_check_13;
  tUInt8 DEF_CAN_FIRE___me_check_13;
  tUInt8 DEF_WILL_FIRE___me_check_12;
  tUInt8 DEF_CAN_FIRE___me_check_12;
  tUInt8 DEF_WILL_FIRE___me_check_11;
  tUInt8 DEF_CAN_FIRE___me_check_11;
  tUInt8 DEF_WILL_FIRE___me_check_10;
  tUInt8 DEF_CAN_FIRE___me_check_10;
  tUInt8 DEF_WILL_FIRE___me_check_9;
  tUInt8 DEF_CAN_FIRE___me_check_9;
  tUInt8 DEF_WILL_FIRE___me_check_8;
  tUInt8 DEF_CAN_FIRE___me_check_8;
  tUInt8 DEF_WILL_FIRE___me_check_7;
  tUInt8 DEF_CAN_FIRE___me_check_7;
  tUInt8 DEF_WILL_FIRE___me_check_6;
  tUInt8 DEF_CAN_FIRE___me_check_6;
  tUInt8 DEF_WILL_FIRE___me_check_5;
  tUInt8 DEF_CAN_FIRE___me_check_5;
  tUInt8 DEF_WILL_FIRE___me_check_4;
  tUInt8 DEF_CAN_FIRE___me_check_4;
  tUInt8 DEF_WILL_FIRE___me_check_3;
  tUInt8 DEF_CAN_FIRE___me_check_3;
  tUInt8 DEF_WILL_FIRE___me_check_2;
  tUInt8 DEF_CAN_FIRE___me_check_2;
  tUInt8 DEF_WILL_FIRE___me_check_1;
  tUInt8 DEF_CAN_FIRE___me_check_1;
  tUInt8 DEF_WILL_FIRE___me_check_0;
  tUInt8 DEF_CAN_FIRE___me_check_0;
  tUInt8 DEF_WILL_FIRE_RL_rl_assign_op;
  tUInt8 DEF_CAN_FIRE_RL_rl_assign_op;
  tUInt8 DEF_WILL_FIRE_RL_rl_process_instr;
  tUInt8 DEF_CAN_FIRE_RL_rl_process_instr;
  tUInt8 DEF_WILL_FIRE_RL_rl_tp;
  tUInt8 DEF_CAN_FIRE_RL_rl_tp;
  tUInt8 DEF_WILL_FIRE_RL_rl_latch_ir;
  tUInt8 DEF_CAN_FIRE_RL_rl_latch_ir;
  tUInt8 DEF_WILL_FIRE_RL_rl_bypass;
  tUInt8 DEF_CAN_FIRE_RL_rl_bypass;
  tUInt8 DEF_WILL_FIRE_RL_rl_instruction;
  tUInt8 DEF_CAN_FIRE_RL_rl_instruction;
  tUInt8 DEF_WILL_FIRE_RL_rl_print_state;
  tUInt8 DEF_CAN_FIRE_RL_rl_print_state;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_16;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_16;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_15;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_15;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_14;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_14;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_13;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_13;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_12;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_12;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_11;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_11;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_10;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_10;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_9;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_9;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_8;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_8;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_7;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_7;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_6;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_6;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_5;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_5;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_4;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_4;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_3;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_3;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_2;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_2;
  tUInt8 DEF_WILL_FIRE_RL_rl_state_1;
  tUInt8 DEF_CAN_FIRE_RL_rl_state_1;
  tUInt8 DEF_update_ir__h3482;
  tUInt8 DEF_update_dr___d17;
  tUInt8 DEF_exit2_dr___d16;
  tUInt8 DEF_exit2_ir___d15;
  tUInt8 DEF_pause_ir___d14;
  tUInt8 DEF_pause_dr___d13;
  tUInt8 DEF_exit1_ir___d12;
  tUInt8 DEF_exit1_dr___d11;
  tUInt8 DEF_shift_ir__h3372;
  tUInt8 DEF_shift_dr__h3465;
  tUInt8 DEF_capture_ir__h3447;
  tUInt8 DEF_capture_dr___d7;
  tUInt8 DEF_select_ir_scan___d6;
  tUInt8 DEF_select_dr_scan___d5;
  tUInt8 DEF_run_test_idle___d4;
  tUInt8 DEF_test_logic_reset__h3484;
  tUInt8 DEF_i__h3513;
 
 /* Local definitions */
 private:
  tUInt8 DEF_latch_ir___d36;
  tUInt8 DEF_temp___1__h3483;
  tUInt8 DEF__read__h203;
  tUInt8 DEF_tms__h3231;
  tUInt8 DEF_NOT_tms___d3;
 
 /* Rules */
 public:
  void RL_rl_state_1();
  void RL_rl_state_2();
  void RL_rl_state_3();
  void RL_rl_state_4();
  void RL_rl_state_5();
  void RL_rl_state_6();
  void RL_rl_state_7();
  void RL_rl_state_8();
  void RL_rl_state_9();
  void RL_rl_state_10();
  void RL_rl_state_11();
  void RL_rl_state_12();
  void RL_rl_state_13();
  void RL_rl_state_14();
  void RL_rl_state_15();
  void RL_rl_state_16();
  void RL_rl_print_state();
  void RL_rl_instruction();
  void RL_rl_bypass();
  void RL_rl_latch_ir();
  void RL_rl_tp();
  void RL_rl_process_instr();
  void RL_rl_assign_op();
  void __me_check_0();
  void __me_check_1();
  void __me_check_2();
  void __me_check_3();
  void __me_check_4();
  void __me_check_5();
  void __me_check_6();
  void __me_check_7();
  void __me_check_8();
  void __me_check_9();
  void __me_check_10();
  void __me_check_11();
  void __me_check_12();
  void __me_check_13();
  void __me_check_14();
 
 /* Methods */
 public:
 
 /* Reset routines */
 public:
  void reset_RST_N(tUInt8 ARG_rst_in);
 
 /* Static handles to reset routines */
 public:
 
 /* Pointers to reset fns in parent module for asserting output resets */
 private:
 
 /* Functions for the parent module to register its reset fns */
 public:
 
 /* Functions to set the elaborated clock id */
 public:
  void set_clk_0(char const *s);
  void set_clk_1(char const *s);
 
 /* State dumping routine */
 public:
  void dump_state(unsigned int indent);
 
 /* VCD dumping routines */
 public:
  unsigned int dump_VCD_defs(unsigned int levels);
  void dump_VCD(tVCDDumpType dt, unsigned int levels, MOD_mkJtag &backing);
  void vcd_defs(tVCDDumpType dt, MOD_mkJtag &backing);
  void vcd_prims(tVCDDumpType dt, MOD_mkJtag &backing);
};

#endif /* ifndef __mkJtag_h__ */
