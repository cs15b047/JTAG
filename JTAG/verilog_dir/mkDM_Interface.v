//
// Generated by Bluespec Compiler, version 2017.03.beta1 (build 35049, 2017-03-16)
//
// On Sun Jun 25 11:40:19 IST 2017
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDM_Interface(CLK,
		      RST_N);
  input  CLK;
  input  RST_N;

  // register abstractcs
  reg [31 : 0] abstractcs;
  wire [31 : 0] abstractcs$D_IN;
  wire abstractcs$EN;

  // register address
  reg [15 : 0] address;
  wire [15 : 0] address$D_IN;
  wire address$EN;

  // register args_present
  reg args_present;
  wire args_present$D_IN, args_present$EN;

  // register command
  reg [31 : 0] command;
  wire [31 : 0] command$D_IN;
  wire command$EN;

  // register count
  reg [31 : 0] count;
  wire [31 : 0] count$D_IN;
  wire count$EN;

  // register data_0
  reg [31 : 0] data_0;
  wire [31 : 0] data_0$D_IN;
  wire data_0$EN;

  // register data_1
  reg [31 : 0] data_1;
  wire [31 : 0] data_1$D_IN;
  wire data_1$EN;

  // register data_10
  reg [31 : 0] data_10;
  wire [31 : 0] data_10$D_IN;
  wire data_10$EN;

  // register data_11
  reg [31 : 0] data_11;
  wire [31 : 0] data_11$D_IN;
  wire data_11$EN;

  // register data_2
  reg [31 : 0] data_2;
  wire [31 : 0] data_2$D_IN;
  wire data_2$EN;

  // register data_3
  reg [31 : 0] data_3;
  wire [31 : 0] data_3$D_IN;
  wire data_3$EN;

  // register data_4
  reg [31 : 0] data_4;
  wire [31 : 0] data_4$D_IN;
  wire data_4$EN;

  // register data_5
  reg [31 : 0] data_5;
  wire [31 : 0] data_5$D_IN;
  wire data_5$EN;

  // register data_6
  reg [31 : 0] data_6;
  wire [31 : 0] data_6$D_IN;
  wire data_6$EN;

  // register data_7
  reg [31 : 0] data_7;
  wire [31 : 0] data_7$D_IN;
  wire data_7$EN;

  // register data_8
  reg [31 : 0] data_8;
  wire [31 : 0] data_8$D_IN;
  wire data_8$EN;

  // register data_9
  reg [31 : 0] data_9;
  wire [31 : 0] data_9$D_IN;
  wire data_9$EN;

  // register dba
  reg [49 : 0] dba;
  wire [49 : 0] dba$D_IN;
  wire dba$EN;

  // register dmcontrol
  reg [31 : 0] dmcontrol;
  reg [31 : 0] dmcontrol$D_IN;
  wire dmcontrol$EN;

  // register dmstatus
  reg [31 : 0] dmstatus;
  wire [31 : 0] dmstatus$D_IN;
  wire dmstatus$EN;

  // register flag
  reg [31 : 0] flag;
  wire [31 : 0] flag$D_IN;
  wire flag$EN;

  // register handle_bypass
  reg handle_bypass;
  wire handle_bypass$D_IN, handle_bypass$EN;

  // register handle_bypass_select
  reg handle_bypass_select;
  wire handle_bypass_select$D_IN, handle_bypass_select$EN;

  // register handle_bypass_tdo
  reg handle_bypass_tdo;
  wire handle_bypass_tdo$D_IN, handle_bypass_tdo$EN;

  // register handle_capture_dr
  reg handle_capture_dr;
  wire handle_capture_dr$D_IN, handle_capture_dr$EN;

  // register handle_capture_ir
  reg handle_capture_ir;
  wire handle_capture_ir$D_IN, handle_capture_ir$EN;

  // register handle_command
  reg [31 : 0] handle_command;
  wire [31 : 0] handle_command$D_IN;
  wire handle_command$EN;

  // register handle_command_select
  reg handle_command_select;
  wire handle_command_select$D_IN, handle_command_select$EN;

  // register handle_command_tdo
  reg handle_command_tdo;
  wire handle_command_tdo$D_IN, handle_command_tdo$EN;

  // register handle_count_tdi
  reg [31 : 0] handle_count_tdi;
  wire [31 : 0] handle_count_tdi$D_IN;
  wire handle_count_tdi$EN;

  // register handle_count_tms
  reg [31 : 0] handle_count_tms;
  wire [31 : 0] handle_count_tms$D_IN;
  wire handle_count_tms$EN;

  // register handle_dba
  reg [49 : 0] handle_dba;
  wire [49 : 0] handle_dba$D_IN;
  wire handle_dba$EN;

  // register handle_dba_tdo
  reg handle_dba_tdo;
  wire handle_dba_tdo$D_IN, handle_dba_tdo$EN;

  // register handle_debug_select
  reg handle_debug_select;
  wire handle_debug_select$D_IN, handle_debug_select$EN;

  // register handle_dtm_control
  reg [31 : 0] handle_dtm_control;
  wire [31 : 0] handle_dtm_control$D_IN;
  wire handle_dtm_control$EN;

  // register handle_dtm_control_tdo
  reg handle_dtm_control_tdo;
  wire handle_dtm_control_tdo$D_IN, handle_dtm_control_tdo$EN;

  // register handle_exit1_dr
  reg handle_exit1_dr;
  wire handle_exit1_dr$D_IN, handle_exit1_dr$EN;

  // register handle_exit1_ir
  reg handle_exit1_ir;
  wire handle_exit1_ir$D_IN, handle_exit1_ir$EN;

  // register handle_exit2_dr
  reg handle_exit2_dr;
  wire handle_exit2_dr$D_IN, handle_exit2_dr$EN;

  // register handle_exit2_ir
  reg handle_exit2_ir;
  wire handle_exit2_ir$D_IN, handle_exit2_ir$EN;

  // register handle_extest_select
  reg handle_extest_select;
  wire handle_extest_select$D_IN, handle_extest_select$EN;

  // register handle_idcode
  reg [31 : 0] handle_idcode;
  wire [31 : 0] handle_idcode$D_IN;
  wire handle_idcode$EN;

  // register handle_idcode_select
  reg handle_idcode_select;
  wire handle_idcode_select$D_IN, handle_idcode_select$EN;

  // register handle_idcode_tdo
  reg handle_idcode_tdo;
  wire handle_idcode_tdo$D_IN, handle_idcode_tdo$EN;

  // register handle_instr_tdo
  reg handle_instr_tdo;
  wire handle_instr_tdo$D_IN, handle_instr_tdo$EN;

  // register handle_instruction
  reg [4 : 0] handle_instruction;
  wire [4 : 0] handle_instruction$D_IN;
  wire handle_instruction$EN;

  // register handle_latch_bypass
  reg handle_latch_bypass;
  wire handle_latch_bypass$D_IN, handle_latch_bypass$EN;

  // register handle_latch_command
  reg [31 : 0] handle_latch_command;
  wire [31 : 0] handle_latch_command$D_IN;
  wire handle_latch_command$EN;

  // register handle_latch_dba
  reg [49 : 0] handle_latch_dba;
  wire [49 : 0] handle_latch_dba$D_IN;
  wire handle_latch_dba$EN;

  // register handle_latch_dtm_control
  reg [31 : 0] handle_latch_dtm_control;
  wire [31 : 0] handle_latch_dtm_control$D_IN;
  wire handle_latch_dtm_control$EN;

  // register handle_latch_idcode
  reg [31 : 0] handle_latch_idcode;
  wire [31 : 0] handle_latch_idcode$D_IN;
  wire handle_latch_idcode$EN;

  // register handle_latch_ir
  reg [4 : 0] handle_latch_ir;
  wire [4 : 0] handle_latch_ir$D_IN;
  wire handle_latch_ir$EN;

  // register handle_pause_dr
  reg handle_pause_dr;
  wire handle_pause_dr$D_IN, handle_pause_dr$EN;

  // register handle_pause_ir
  reg handle_pause_ir;
  wire handle_pause_ir$D_IN, handle_pause_ir$EN;

  // register handle_run_test_idle
  reg handle_run_test_idle;
  wire handle_run_test_idle$D_IN, handle_run_test_idle$EN;

  // register handle_sample_preload_select
  reg handle_sample_preload_select;
  wire handle_sample_preload_select$D_IN, handle_sample_preload_select$EN;

  // register handle_select_dr_scan
  reg handle_select_dr_scan;
  wire handle_select_dr_scan$D_IN, handle_select_dr_scan$EN;

  // register handle_select_ir_scan
  reg handle_select_ir_scan;
  wire handle_select_ir_scan$D_IN, handle_select_ir_scan$EN;

  // register handle_shift_dr
  reg handle_shift_dr;
  wire handle_shift_dr$D_IN, handle_shift_dr$EN;

  // register handle_shift_ir
  reg handle_shift_ir;
  wire handle_shift_ir$D_IN, handle_shift_ir$EN;

  // register handle_shift_ir_neg
  reg handle_shift_ir_neg;
  wire handle_shift_ir_neg$D_IN, handle_shift_ir_neg$EN;

  // register handle_state
  reg [31 : 0] handle_state;
  reg [31 : 0] handle_state$D_IN;
  wire handle_state$EN;

  // register handle_tdi
  reg handle_tdi;
  wire handle_tdi$D_IN, handle_tdi$EN;

  // register handle_tdi_vec
  reg [35 : 0] handle_tdi_vec;
  wire [35 : 0] handle_tdi_vec$D_IN;
  wire handle_tdi_vec$EN;

  // register handle_tdo
  reg handle_tdo;
  reg handle_tdo$D_IN;
  wire handle_tdo$EN;

  // register handle_tdo_enable
  reg handle_tdo_enable;
  wire handle_tdo_enable$D_IN, handle_tdo_enable$EN;

  // register handle_test_logic_reset
  reg handle_test_logic_reset;
  wire handle_test_logic_reset$D_IN, handle_test_logic_reset$EN;

  // register handle_tms
  reg handle_tms;
  wire handle_tms$D_IN, handle_tms$EN;

  // register handle_tms_vec
  reg [47 : 0] handle_tms_vec;
  wire [47 : 0] handle_tms_vec$D_IN;
  wire handle_tms_vec$EN;

  // register handle_update_dr
  reg handle_update_dr;
  wire handle_update_dr$D_IN, handle_update_dr$EN;

  // register handle_update_ir
  reg handle_update_ir;
  wire handle_update_ir$D_IN, handle_update_ir$EN;

  // register hartinfo
  reg [31 : 0] hartinfo;
  wire [31 : 0] hartinfo$D_IN;
  wire hartinfo$EN;

  // register num_args
  reg [31 : 0] num_args;
  reg [31 : 0] num_args$D_IN;
  wire num_args$EN;

  // register read_data
  reg [31 : 0] read_data;
  wire [31 : 0] read_data$D_IN;
  wire read_data$EN;

  // register read_data_flag
  reg read_data_flag;
  wire read_data_flag$D_IN, read_data_flag$EN;

  // register ready_read
  reg ready_read;
  wire ready_read$D_IN, ready_read$EN;

  // register rg_cmd
  reg [7 : 0] rg_cmd;
  reg [7 : 0] rg_cmd$D_IN;
  wire rg_cmd$EN;

  // register write_data_flag
  reg write_data_flag;
  wire write_data_flag$D_IN, write_data_flag$EN;

  // ports of submodule fifo_args
  wire [31 : 0] fifo_args$D_IN;
  wire fifo_args$CLR, fifo_args$DEQ, fifo_args$ENQ;

  // ports of submodule fifo_cmd
  wire [31 : 0] fifo_cmd$D_IN, fifo_cmd$D_OUT;
  wire fifo_cmd$CLR,
       fifo_cmd$DEQ,
       fifo_cmd$EMPTY_N,
       fifo_cmd$ENQ,
       fifo_cmd$FULL_N;

  // ports of submodule handle_fifo_bypass
  wire handle_fifo_bypass$CLR,
       handle_fifo_bypass$DEQ,
       handle_fifo_bypass$D_IN,
       handle_fifo_bypass$ENQ;

  // ports of submodule handle_fifo_cmd
  wire [31 : 0] handle_fifo_cmd$D_IN;
  wire handle_fifo_cmd$CLR, handle_fifo_cmd$DEQ, handle_fifo_cmd$ENQ;

  // ports of submodule handle_fifo_dba
  wire [49 : 0] handle_fifo_dba$D_IN;
  wire handle_fifo_dba$CLR, handle_fifo_dba$DEQ, handle_fifo_dba$ENQ;

  // ports of submodule handle_fifo_dtm
  wire [31 : 0] handle_fifo_dtm$D_IN;
  wire handle_fifo_dtm$CLR, handle_fifo_dtm$DEQ, handle_fifo_dtm$ENQ;

  // ports of submodule handle_fifo_idcode
  wire [31 : 0] handle_fifo_idcode$D_IN;
  wire handle_fifo_idcode$CLR, handle_fifo_idcode$DEQ, handle_fifo_idcode$ENQ;

  // ports of submodule handle_inverted
  wire handle_inverted$CLK_OUT;

  // rule scheduling signals
  wire CAN_FIRE_RL_handle_cross_bypass_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_command_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_count_tdi_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_count_tms_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_dba_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_dtm_control_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_idcode_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_instruction_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_latch_bypass_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_latch_command_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_latch_dba_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_latch_dtm_control_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_latch_idcode_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_latch_ir_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_shift_dr_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_shift_ir_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_tdi_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_tdi_vec_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_tdo_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_test_logic_reset_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_tms_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_tms_vec_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_update_dr_clock_domain_crossing,
       CAN_FIRE_RL_handle_cross_update_ir_clock_domain_crossing,
       CAN_FIRE_RL_handle_rl_assign_op,
       CAN_FIRE_RL_handle_rl_buffer1,
       CAN_FIRE_RL_handle_rl_buffer2,
       CAN_FIRE_RL_handle_rl_data,
       CAN_FIRE_RL_handle_rl_inc_count,
       CAN_FIRE_RL_handle_rl_instruction,
       CAN_FIRE_RL_handle_rl_print_state1,
       CAN_FIRE_RL_handle_rl_shift_out,
       CAN_FIRE_RL_handle_rl_state_1,
       CAN_FIRE_RL_handle_rl_state_10,
       CAN_FIRE_RL_handle_rl_state_11,
       CAN_FIRE_RL_handle_rl_state_12,
       CAN_FIRE_RL_handle_rl_state_13,
       CAN_FIRE_RL_handle_rl_state_14,
       CAN_FIRE_RL_handle_rl_state_15,
       CAN_FIRE_RL_handle_rl_state_16,
       CAN_FIRE_RL_handle_rl_state_2,
       CAN_FIRE_RL_handle_rl_state_3,
       CAN_FIRE_RL_handle_rl_state_4,
       CAN_FIRE_RL_handle_rl_state_5,
       CAN_FIRE_RL_handle_rl_state_6,
       CAN_FIRE_RL_handle_rl_state_7,
       CAN_FIRE_RL_handle_rl_state_8,
       CAN_FIRE_RL_handle_rl_state_9,
       CAN_FIRE_RL_handle_rl_tp,
       CAN_FIRE_RL_handle_rl_update_data,
       CAN_FIRE_RL_handle_rl_update_ir,
       CAN_FIRE_RL_rl_dba_type,
       CAN_FIRE_RL_rl_halt_or_reset,
       CAN_FIRE_RL_rl_print,
       CAN_FIRE_RL_rl_read_data,
       CAN_FIRE_RL_rl_take_args,
       CAN_FIRE_RL_rl_take_cmd,
       CAN_FIRE_RL_rl_understand_cmd,
       CAN_FIRE_RL_rl_write_data,
       CAN_FIRE___me_check_24,
       CAN_FIRE___me_check_25,
       CAN_FIRE___me_check_26,
       CAN_FIRE___me_check_27,
       CAN_FIRE___me_check_28,
       CAN_FIRE___me_check_29,
       CAN_FIRE___me_check_30,
       CAN_FIRE___me_check_31,
       CAN_FIRE___me_check_32,
       CAN_FIRE___me_check_33,
       CAN_FIRE___me_check_34,
       CAN_FIRE___me_check_35,
       CAN_FIRE___me_check_36,
       CAN_FIRE___me_check_37,
       CAN_FIRE___me_check_38,
       WILL_FIRE_RL_handle_cross_bypass_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_command_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_count_tdi_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_count_tms_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_dba_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_dtm_control_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_idcode_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_instruction_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_latch_bypass_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_latch_command_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_latch_dba_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_latch_dtm_control_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_latch_idcode_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_latch_ir_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_shift_dr_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_shift_ir_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_tdi_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_tdi_vec_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_tdo_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_test_logic_reset_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_tms_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_tms_vec_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_update_dr_clock_domain_crossing,
       WILL_FIRE_RL_handle_cross_update_ir_clock_domain_crossing,
       WILL_FIRE_RL_handle_rl_assign_op,
       WILL_FIRE_RL_handle_rl_buffer1,
       WILL_FIRE_RL_handle_rl_buffer2,
       WILL_FIRE_RL_handle_rl_data,
       WILL_FIRE_RL_handle_rl_inc_count,
       WILL_FIRE_RL_handle_rl_instruction,
       WILL_FIRE_RL_handle_rl_print_state1,
       WILL_FIRE_RL_handle_rl_shift_out,
       WILL_FIRE_RL_handle_rl_state_1,
       WILL_FIRE_RL_handle_rl_state_10,
       WILL_FIRE_RL_handle_rl_state_11,
       WILL_FIRE_RL_handle_rl_state_12,
       WILL_FIRE_RL_handle_rl_state_13,
       WILL_FIRE_RL_handle_rl_state_14,
       WILL_FIRE_RL_handle_rl_state_15,
       WILL_FIRE_RL_handle_rl_state_16,
       WILL_FIRE_RL_handle_rl_state_2,
       WILL_FIRE_RL_handle_rl_state_3,
       WILL_FIRE_RL_handle_rl_state_4,
       WILL_FIRE_RL_handle_rl_state_5,
       WILL_FIRE_RL_handle_rl_state_6,
       WILL_FIRE_RL_handle_rl_state_7,
       WILL_FIRE_RL_handle_rl_state_8,
       WILL_FIRE_RL_handle_rl_state_9,
       WILL_FIRE_RL_handle_rl_tp,
       WILL_FIRE_RL_handle_rl_update_data,
       WILL_FIRE_RL_handle_rl_update_ir,
       WILL_FIRE_RL_rl_dba_type,
       WILL_FIRE_RL_rl_halt_or_reset,
       WILL_FIRE_RL_rl_print,
       WILL_FIRE_RL_rl_read_data,
       WILL_FIRE_RL_rl_take_args,
       WILL_FIRE_RL_rl_take_cmd,
       WILL_FIRE_RL_rl_understand_cmd,
       WILL_FIRE_RL_rl_write_data,
       WILL_FIRE___me_check_24,
       WILL_FIRE___me_check_25,
       WILL_FIRE___me_check_26,
       WILL_FIRE___me_check_27,
       WILL_FIRE___me_check_28,
       WILL_FIRE___me_check_29,
       WILL_FIRE___me_check_30,
       WILL_FIRE___me_check_31,
       WILL_FIRE___me_check_32,
       WILL_FIRE___me_check_33,
       WILL_FIRE___me_check_34,
       WILL_FIRE___me_check_35,
       WILL_FIRE___me_check_36,
       WILL_FIRE___me_check_37,
       WILL_FIRE___me_check_38;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_count$write_1__VAL_2;
  wire MUX_count$write_1__SEL_1,
       MUX_flag$write_1__SEL_1,
       MUX_handle_capture_dr$write_1__SEL_1,
       MUX_handle_capture_ir$write_1__SEL_1,
       MUX_handle_exit1_dr$write_1__PSEL_1,
       MUX_handle_exit1_dr$write_1__SEL_1,
       MUX_handle_exit1_ir$write_1__SEL_1,
       MUX_handle_exit2_dr$write_1__SEL_1,
       MUX_handle_exit2_ir$write_1__PSEL_1,
       MUX_handle_exit2_ir$write_1__SEL_1,
       MUX_handle_pause_ir$write_1__SEL_1,
       MUX_handle_run_test_idle$write_1__SEL_1,
       MUX_handle_select_dr_scan$write_1__PSEL_1,
       MUX_handle_select_dr_scan$write_1__SEL_1,
       MUX_handle_select_ir_scan$write_1__SEL_1,
       MUX_handle_shift_dr$write_1__SEL_1,
       MUX_handle_state$write_1__SEL_1,
       MUX_handle_test_logic_reset$write_1__SEL_1,
       MUX_handle_update_dr$write_1__PSEL_1,
       MUX_handle_update_dr$write_1__SEL_1,
       MUX_handle_update_ir$write_1__PSEL_1,
       MUX_handle_update_ir$write_1__SEL_1,
       MUX_read_data_flag$write_1__SEL_1,
       MUX_write_data_flag$write_1__SEL_1;

  // remaining internal signals
  wire [49 : 0] temp_dba___1__h9222;
  wire [31 : 0] temp_command___1__h9065,
		temp_dtm___1__h9379,
		temp_idcode___1__h9597,
		v__h10833,
		v__h11074,
		v__h11542;
  wire [4 : 0] temp___1__h8879;
  wire count_74_EQ_num_args_75___d213;

  // submodule fifo_args
  FIFO2 #(.width(32'd32), .guarded(32'd1)) fifo_args(.RST(RST_N),
						     .CLK(CLK),
						     .D_IN(fifo_args$D_IN),
						     .ENQ(fifo_args$ENQ),
						     .DEQ(fifo_args$DEQ),
						     .CLR(fifo_args$CLR),
						     .D_OUT(),
						     .FULL_N(),
						     .EMPTY_N());

  // submodule fifo_cmd
  FIFO2 #(.width(32'd32), .guarded(32'd1)) fifo_cmd(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(fifo_cmd$D_IN),
						    .ENQ(fifo_cmd$ENQ),
						    .DEQ(fifo_cmd$DEQ),
						    .CLR(fifo_cmd$CLR),
						    .D_OUT(fifo_cmd$D_OUT),
						    .FULL_N(fifo_cmd$FULL_N),
						    .EMPTY_N(fifo_cmd$EMPTY_N));

  // submodule handle_fifo_bypass
  FIFO2 #(.width(32'd1), .guarded(32'd1)) handle_fifo_bypass(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(handle_fifo_bypass$D_IN),
							     .ENQ(handle_fifo_bypass$ENQ),
							     .DEQ(handle_fifo_bypass$DEQ),
							     .CLR(handle_fifo_bypass$CLR),
							     .D_OUT(),
							     .FULL_N(),
							     .EMPTY_N());

  // submodule handle_fifo_cmd
  FIFO2 #(.width(32'd32), .guarded(32'd1)) handle_fifo_cmd(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(handle_fifo_cmd$D_IN),
							   .ENQ(handle_fifo_cmd$ENQ),
							   .DEQ(handle_fifo_cmd$DEQ),
							   .CLR(handle_fifo_cmd$CLR),
							   .D_OUT(),
							   .FULL_N(),
							   .EMPTY_N());

  // submodule handle_fifo_dba
  FIFO2 #(.width(32'd50), .guarded(32'd1)) handle_fifo_dba(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(handle_fifo_dba$D_IN),
							   .ENQ(handle_fifo_dba$ENQ),
							   .DEQ(handle_fifo_dba$DEQ),
							   .CLR(handle_fifo_dba$CLR),
							   .D_OUT(),
							   .FULL_N(),
							   .EMPTY_N());

  // submodule handle_fifo_dtm
  FIFO2 #(.width(32'd32), .guarded(32'd1)) handle_fifo_dtm(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(handle_fifo_dtm$D_IN),
							   .ENQ(handle_fifo_dtm$ENQ),
							   .DEQ(handle_fifo_dtm$DEQ),
							   .CLR(handle_fifo_dtm$CLR),
							   .D_OUT(),
							   .FULL_N(),
							   .EMPTY_N());

  // submodule handle_fifo_idcode
  FIFO2 #(.width(32'd32), .guarded(32'd1)) handle_fifo_idcode(.RST(RST_N),
							      .CLK(CLK),
							      .D_IN(handle_fifo_idcode$D_IN),
							      .ENQ(handle_fifo_idcode$ENQ),
							      .DEQ(handle_fifo_idcode$DEQ),
							      .CLR(handle_fifo_idcode$CLR),
							      .D_OUT(),
							      .FULL_N(),
							      .EMPTY_N());

  // submodule handle_inverted
  ClockInverter handle_inverted(.CLK_IN(CLK),
				.PREEDGE(),
				.CLK_OUT(handle_inverted$CLK_OUT));

  // rule RL_rl_take_cmd
  assign CAN_FIRE_RL_rl_take_cmd =
	     handle_latch_ir == 5'd18 && handle_state == 32'd2 &&
	     fifo_cmd$FULL_N ;
  assign WILL_FIRE_RL_rl_take_cmd = CAN_FIRE_RL_rl_take_cmd ;

  // rule RL_rl_take_args
  assign CAN_FIRE_RL_rl_take_args =
	     handle_latch_ir == 5'd17 && handle_state == 32'd2 &&
	     args_present &&
	     count < num_args &&
	     flag == 32'd1 ;
  assign WILL_FIRE_RL_rl_take_args = CAN_FIRE_RL_rl_take_args ;

  // rule RL_rl_read_data
  assign CAN_FIRE_RL_rl_read_data = read_data_flag ;
  assign WILL_FIRE_RL_rl_read_data = read_data_flag ;

  // rule RL_rl_write_data
  assign CAN_FIRE_RL_rl_write_data = write_data_flag ;
  assign WILL_FIRE_RL_rl_write_data = write_data_flag ;

  // rule RL_rl_dba_type
  assign CAN_FIRE_RL_rl_dba_type =
	     flag == 32'd1 && args_present && count_74_EQ_num_args_75___d213 ;
  assign WILL_FIRE_RL_rl_dba_type = CAN_FIRE_RL_rl_dba_type ;

  // rule RL_rl_print
  assign CAN_FIRE_RL_rl_print =
	     flag == 32'd1 && count_74_EQ_num_args_75___d213 ;
  assign WILL_FIRE_RL_rl_print = CAN_FIRE_RL_rl_print ;

  // rule RL_rl_halt_or_reset
  assign CAN_FIRE_RL_rl_halt_or_reset = 1'd1 ;
  assign WILL_FIRE_RL_rl_halt_or_reset = 1'd1 ;

  // rule RL_rl_understand_cmd
  assign CAN_FIRE_RL_rl_understand_cmd = fifo_cmd$EMPTY_N && flag == 32'd0 ;
  assign WILL_FIRE_RL_rl_understand_cmd = CAN_FIRE_RL_rl_understand_cmd ;

  // rule RL_handle_rl_print_state1
  assign CAN_FIRE_RL_handle_rl_print_state1 = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_print_state1 = 1'd1 ;

  // rule RL_handle_rl_state_2
  assign CAN_FIRE_RL_handle_rl_state_2 = handle_run_test_idle ;
  assign WILL_FIRE_RL_handle_rl_state_2 = handle_run_test_idle ;

  // rule RL_handle_rl_state_11
  assign CAN_FIRE_RL_handle_rl_state_11 = handle_pause_dr ;
  assign WILL_FIRE_RL_handle_rl_state_11 = handle_pause_dr ;

  // rule RL_handle_rl_state_12
  assign CAN_FIRE_RL_handle_rl_state_12 = handle_pause_ir ;
  assign WILL_FIRE_RL_handle_rl_state_12 = handle_pause_ir ;

  // rule RL_handle_rl_buffer1
  assign CAN_FIRE_RL_handle_rl_buffer1 =
	     handle_update_dr && handle_state == 32'd0 ;
  assign WILL_FIRE_RL_handle_rl_buffer1 = CAN_FIRE_RL_handle_rl_buffer1 ;

  // rule RL_handle_rl_buffer2
  assign CAN_FIRE_RL_handle_rl_buffer2 = handle_state == 32'd1 ;
  assign WILL_FIRE_RL_handle_rl_buffer2 = CAN_FIRE_RL_handle_rl_buffer2 ;

  // rule RL_handle_cross_tms_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_tms_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_tms_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_tp
  assign CAN_FIRE_RL_handle_rl_tp = handle_count_tms < 32'd48 ;
  assign WILL_FIRE_RL_handle_rl_tp = CAN_FIRE_RL_handle_rl_tp ;

  // rule RL_handle_cross_count_tms_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_count_tms_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_count_tms_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_tms_vec_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_tms_vec_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_tms_vec_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_count_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_count_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_count_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_tdi_vec_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_tdi_vec_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_tdi_vec_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_tdo_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_tdo_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_tdo_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_assign_op
  assign CAN_FIRE_RL_handle_rl_assign_op = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_assign_op = 1'd1 ;

  // rule RL_handle_rl_shift_out
  assign CAN_FIRE_RL_handle_rl_shift_out = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_shift_out = 1'd1 ;

  // rule RL_handle_cross_latch_dba_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_latch_dba_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_latch_dba_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_latch_command_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_latch_command_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_latch_command_clock_domain_crossing =
	     1'd1 ;

  // rule RL_handle_cross_latch_dtm_control_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_latch_dtm_control_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_handle_cross_latch_dtm_control_clock_domain_crossing =
	     1'd1 ;

  // rule RL_handle_cross_latch_bypass_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_latch_bypass_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_latch_bypass_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_latch_idcode_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_latch_idcode_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_latch_idcode_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_update_data
  assign CAN_FIRE_RL_handle_rl_update_data = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_update_data = 1'd1 ;

  // rule RL_handle_cross_latch_ir_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_latch_ir_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_latch_ir_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_update_ir
  assign CAN_FIRE_RL_handle_rl_update_ir = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_update_ir = 1'd1 ;

  // rule RL_handle_cross_dba_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_dba_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_dba_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_command_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_command_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_command_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_dtm_control_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_dtm_control_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_dtm_control_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_bypass_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_bypass_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_bypass_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_cross_idcode_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_idcode_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_idcode_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_data
  assign CAN_FIRE_RL_handle_rl_data = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_data = 1'd1 ;

  // rule RL_handle_rl_state_3
  assign CAN_FIRE_RL_handle_rl_state_3 = handle_select_dr_scan ;
  assign WILL_FIRE_RL_handle_rl_state_3 = handle_select_dr_scan ;

  // rule RL_handle_cross_instruction_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_instruction_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_instruction_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_instruction
  assign CAN_FIRE_RL_handle_rl_instruction = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_instruction = 1'd1 ;

  // rule RL_handle_rl_inc_count
  assign CAN_FIRE_RL_handle_rl_inc_count = 1'd1 ;
  assign WILL_FIRE_RL_handle_rl_inc_count = 1'd1 ;

  // rule RL_handle_cross_update_dr_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_update_dr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_update_dr_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_state_9
  assign CAN_FIRE_RL_handle_rl_state_9 = handle_exit1_dr ;
  assign WILL_FIRE_RL_handle_rl_state_9 = handle_exit1_dr ;

  // rule RL_handle_rl_state_15
  assign CAN_FIRE_RL_handle_rl_state_15 = handle_update_dr ;
  assign WILL_FIRE_RL_handle_rl_state_15 = handle_update_dr ;

  // rule RL_handle_cross_update_ir_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_update_ir_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_update_ir_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_state_10
  assign CAN_FIRE_RL_handle_rl_state_10 = handle_exit1_ir ;
  assign WILL_FIRE_RL_handle_rl_state_10 = handle_exit1_ir ;

  // rule RL_handle_rl_state_16
  assign CAN_FIRE_RL_handle_rl_state_16 = handle_update_ir ;
  assign WILL_FIRE_RL_handle_rl_state_16 = handle_update_ir ;

  // rule __me_check_38
  assign CAN_FIRE___me_check_38 = 1'b1 ;
  assign WILL_FIRE___me_check_38 = 1'b1 ;

  // rule RL_handle_cross_test_logic_reset_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_test_logic_reset_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_handle_cross_test_logic_reset_clock_domain_crossing =
	     1'd1 ;

  // rule RL_handle_rl_state_1
  assign CAN_FIRE_RL_handle_rl_state_1 = handle_test_logic_reset ;
  assign WILL_FIRE_RL_handle_rl_state_1 = handle_test_logic_reset ;

  // rule RL_handle_rl_state_4
  assign CAN_FIRE_RL_handle_rl_state_4 = handle_select_ir_scan ;
  assign WILL_FIRE_RL_handle_rl_state_4 = handle_select_ir_scan ;

  // rule RL_handle_cross_shift_dr_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_shift_dr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_shift_dr_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_state_5
  assign CAN_FIRE_RL_handle_rl_state_5 = handle_capture_dr ;
  assign WILL_FIRE_RL_handle_rl_state_5 = handle_capture_dr ;

  // rule RL_handle_rl_state_7
  assign CAN_FIRE_RL_handle_rl_state_7 = handle_shift_dr ;
  assign WILL_FIRE_RL_handle_rl_state_7 = handle_shift_dr ;

  // rule RL_handle_rl_state_14
  assign CAN_FIRE_RL_handle_rl_state_14 = handle_exit2_dr ;
  assign WILL_FIRE_RL_handle_rl_state_14 = handle_exit2_dr ;

  // rule __me_check_37
  assign CAN_FIRE___me_check_37 = 1'b1 ;
  assign WILL_FIRE___me_check_37 = 1'b1 ;

  // rule RL_handle_cross_shift_ir_clock_domain_crossing
  assign CAN_FIRE_RL_handle_cross_shift_ir_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_handle_cross_shift_ir_clock_domain_crossing = 1'd1 ;

  // rule RL_handle_rl_state_6
  assign CAN_FIRE_RL_handle_rl_state_6 = handle_capture_ir ;
  assign WILL_FIRE_RL_handle_rl_state_6 = handle_capture_ir ;

  // rule RL_handle_rl_state_8
  assign CAN_FIRE_RL_handle_rl_state_8 = handle_shift_ir ;
  assign WILL_FIRE_RL_handle_rl_state_8 = handle_shift_ir ;

  // rule RL_handle_rl_state_13
  assign CAN_FIRE_RL_handle_rl_state_13 = handle_exit2_ir ;
  assign WILL_FIRE_RL_handle_rl_state_13 = handle_exit2_ir ;

  // rule __me_check_24
  assign CAN_FIRE___me_check_24 = 1'b1 ;
  assign WILL_FIRE___me_check_24 = 1'b1 ;

  // rule __me_check_25
  assign CAN_FIRE___me_check_25 = 1'b1 ;
  assign WILL_FIRE___me_check_25 = 1'b1 ;

  // rule __me_check_26
  assign CAN_FIRE___me_check_26 = 1'b1 ;
  assign WILL_FIRE___me_check_26 = 1'b1 ;

  // rule __me_check_27
  assign CAN_FIRE___me_check_27 = 1'b1 ;
  assign WILL_FIRE___me_check_27 = 1'b1 ;

  // rule __me_check_28
  assign CAN_FIRE___me_check_28 = 1'b1 ;
  assign WILL_FIRE___me_check_28 = 1'b1 ;

  // rule __me_check_29
  assign CAN_FIRE___me_check_29 = 1'b1 ;
  assign WILL_FIRE___me_check_29 = 1'b1 ;

  // rule __me_check_30
  assign CAN_FIRE___me_check_30 = 1'b1 ;
  assign WILL_FIRE___me_check_30 = 1'b1 ;

  // rule __me_check_31
  assign CAN_FIRE___me_check_31 = 1'b1 ;
  assign WILL_FIRE___me_check_31 = 1'b1 ;

  // rule __me_check_32
  assign CAN_FIRE___me_check_32 = 1'b1 ;
  assign WILL_FIRE___me_check_32 = 1'b1 ;

  // rule __me_check_33
  assign CAN_FIRE___me_check_33 = 1'b1 ;
  assign WILL_FIRE___me_check_33 = 1'b1 ;

  // rule __me_check_34
  assign CAN_FIRE___me_check_34 = 1'b1 ;
  assign WILL_FIRE___me_check_34 = 1'b1 ;

  // rule __me_check_35
  assign CAN_FIRE___me_check_35 = 1'b1 ;
  assign WILL_FIRE___me_check_35 = 1'b1 ;

  // rule __me_check_36
  assign CAN_FIRE___me_check_36 = 1'b1 ;
  assign WILL_FIRE___me_check_36 = 1'b1 ;

  // inputs to muxes for submodule ports
  assign MUX_count$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_understand_cmd &&
	     (fifo_cmd$D_OUT[7:0] == 8'b00000011 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000100) ;
  assign MUX_flag$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_understand_cmd &&
	     (fifo_cmd$D_OUT[7:0] == 8'b00000001 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000010 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000011 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000100) ;
  assign MUX_handle_capture_dr$write_1__SEL_1 =
	     handle_select_dr_scan && !handle_tms ;
  assign MUX_handle_capture_ir$write_1__SEL_1 =
	     handle_select_ir_scan && !handle_tms ;
  assign MUX_handle_exit1_dr$write_1__PSEL_1 =
	     handle_shift_dr || handle_capture_dr ;
  assign MUX_handle_exit1_dr$write_1__SEL_1 =
	     MUX_handle_exit1_dr$write_1__PSEL_1 && handle_tms ;
  assign MUX_handle_exit1_ir$write_1__SEL_1 = handle_shift_ir && handle_tms ;
  assign MUX_handle_exit2_dr$write_1__SEL_1 = handle_pause_dr && handle_tms ;
  assign MUX_handle_exit2_ir$write_1__PSEL_1 =
	     handle_pause_ir || handle_capture_ir ;
  assign MUX_handle_exit2_ir$write_1__SEL_1 =
	     MUX_handle_exit2_ir$write_1__PSEL_1 && handle_tms ;
  assign MUX_handle_pause_ir$write_1__SEL_1 = handle_pause_ir && handle_tms ;
  assign MUX_handle_run_test_idle$write_1__SEL_1 =
	     handle_run_test_idle && handle_tms ;
  assign MUX_handle_select_dr_scan$write_1__PSEL_1 =
	     handle_update_ir || handle_update_dr || handle_run_test_idle ;
  assign MUX_handle_select_dr_scan$write_1__SEL_1 =
	     MUX_handle_select_dr_scan$write_1__PSEL_1 && handle_tms ;
  assign MUX_handle_select_ir_scan$write_1__SEL_1 =
	     handle_select_dr_scan && handle_tms ;
  assign MUX_handle_shift_dr$write_1__SEL_1 = handle_shift_dr && handle_tms ;
  assign MUX_handle_state$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_take_args || WILL_FIRE_RL_rl_take_cmd ;
  assign MUX_handle_test_logic_reset$write_1__SEL_1 =
	     handle_select_ir_scan && handle_tms ;
  assign MUX_handle_update_dr$write_1__PSEL_1 =
	     handle_exit2_dr || handle_exit1_dr ;
  assign MUX_handle_update_dr$write_1__SEL_1 =
	     MUX_handle_update_dr$write_1__PSEL_1 && handle_tms ;
  assign MUX_handle_update_ir$write_1__PSEL_1 =
	     handle_exit2_ir || handle_exit1_ir ;
  assign MUX_handle_update_ir$write_1__SEL_1 =
	     MUX_handle_update_ir$write_1__PSEL_1 && handle_tms ;
  assign MUX_read_data_flag$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_dba_type && dba[1:0] == 2'd1 ;
  assign MUX_write_data_flag$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_dba_type && dba[1:0] == 2'd2 ;
  assign MUX_count$write_1__VAL_2 = count + 32'd1 ;

  // register abstractcs
  assign abstractcs$D_IN = 32'h0 ;
  assign abstractcs$EN = 1'b0 ;

  // register address
  assign address$D_IN = command[15:0] ;
  assign address$EN =
	     WILL_FIRE_RL_rl_dba_type &&
	     (dba[1:0] == 2'd1 || dba[1:0] == 2'd2) ;

  // register args_present
  assign args_present$D_IN =
	     fifo_cmd$D_OUT[7:0] != 8'b00000001 &&
	     fifo_cmd$D_OUT[7:0] != 8'b00000010 ;
  assign args_present$EN = MUX_flag$write_1__SEL_1 ;

  // register command
  assign command$D_IN = { command[31:16], handle_latch_dba[49:34] } ;
  assign command$EN = CAN_FIRE_RL_rl_take_args ;

  // register count
  assign count$D_IN =
	     MUX_count$write_1__SEL_1 ? 32'd0 : MUX_count$write_1__VAL_2 ;
  assign count$EN =
	     WILL_FIRE_RL_rl_understand_cmd &&
	     (fifo_cmd$D_OUT[7:0] == 8'b00000011 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000100) ||
	     WILL_FIRE_RL_rl_take_args ;

  // register data_0
  assign data_0$D_IN = handle_latch_dba[33:2] ;
  assign data_0$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd0 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_1
  assign data_1$D_IN = handle_latch_dba[33:2] ;
  assign data_1$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd1 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_10
  assign data_10$D_IN = handle_latch_dba[33:2] ;
  assign data_10$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd10 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_11
  assign data_11$D_IN = handle_latch_dba[33:2] ;
  assign data_11$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd11 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_2
  assign data_2$D_IN = handle_latch_dba[33:2] ;
  assign data_2$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd2 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_3
  assign data_3$D_IN = handle_latch_dba[33:2] ;
  assign data_3$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd3 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_4
  assign data_4$D_IN = handle_latch_dba[33:2] ;
  assign data_4$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd4 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_5
  assign data_5$D_IN = handle_latch_dba[33:2] ;
  assign data_5$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd5 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_6
  assign data_6$D_IN = handle_latch_dba[33:2] ;
  assign data_6$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd6 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_7
  assign data_7$D_IN = handle_latch_dba[33:2] ;
  assign data_7$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd7 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_8
  assign data_8$D_IN = handle_latch_dba[33:2] ;
  assign data_8$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd8 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register data_9
  assign data_9$D_IN = handle_latch_dba[33:2] ;
  assign data_9$EN =
	     WILL_FIRE_RL_rl_take_args && count == 32'd9 &&
	     handle_latch_dba[1:0] == 2'b10 ;

  // register dba
  assign dba$D_IN = handle_latch_dba ;
  assign dba$EN = CAN_FIRE_RL_rl_take_args ;

  // register dmcontrol
  always@(fifo_cmd$D_OUT or dmcontrol or v__h10833 or v__h11074 or v__h11542)
  begin
    case (fifo_cmd$D_OUT[7:0])
      8'b00000001: dmcontrol$D_IN = v__h10833;
      8'b00000010: dmcontrol$D_IN = v__h11074;
      8'b00000011, 8'b00000100: dmcontrol$D_IN = v__h11542;
      default: dmcontrol$D_IN = dmcontrol;
    endcase
  end
  assign dmcontrol$EN = CAN_FIRE_RL_rl_understand_cmd ;

  // register dmstatus
  assign dmstatus$D_IN = 32'h0 ;
  assign dmstatus$EN = 1'b0 ;

  // register flag
  assign flag$D_IN = MUX_flag$write_1__SEL_1 ? 32'd1 : 32'd0 ;
  assign flag$EN =
	     WILL_FIRE_RL_rl_understand_cmd &&
	     (fifo_cmd$D_OUT[7:0] == 8'b00000001 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000010 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000011 ||
	      fifo_cmd$D_OUT[7:0] == 8'b00000100) ||
	     WILL_FIRE_RL_rl_print ;

  // register handle_bypass
  assign handle_bypass$D_IN =
	     handle_shift_dr ?
	       handle_tdi :
	       handle_capture_dr && handle_latch_bypass ;
  assign handle_bypass$EN =
	     (handle_test_logic_reset || handle_capture_dr ||
	      handle_shift_dr) &&
	     handle_latch_ir == 5'd31 ;

  // register handle_bypass_select
  assign handle_bypass_select$D_IN = 1'b0 ;
  assign handle_bypass_select$EN = 1'b0 ;

  // register handle_bypass_tdo
  assign handle_bypass_tdo$D_IN = handle_bypass ;
  assign handle_bypass_tdo$EN = 1'd1 ;

  // register handle_capture_dr
  assign handle_capture_dr$D_IN = MUX_handle_capture_dr$write_1__SEL_1 ;
  assign handle_capture_dr$EN =
	     handle_select_dr_scan && !handle_tms || handle_capture_dr ;

  // register handle_capture_ir
  assign handle_capture_ir$D_IN = MUX_handle_capture_ir$write_1__SEL_1 ;
  assign handle_capture_ir$EN =
	     handle_select_ir_scan && !handle_tms || handle_capture_ir ;

  // register handle_command
  assign handle_command$D_IN =
	     handle_shift_dr ?
	       temp_command___1__h9065 :
	       (handle_capture_dr ? handle_latch_command : 32'd0) ;
  assign handle_command$EN =
	     (handle_test_logic_reset || handle_capture_dr ||
	      handle_shift_dr) &&
	     handle_latch_ir == 5'd18 ;

  // register handle_command_select
  assign handle_command_select$D_IN = 1'b0 ;
  assign handle_command_select$EN = 1'b0 ;

  // register handle_command_tdo
  assign handle_command_tdo$D_IN = handle_command[0] ;
  assign handle_command_tdo$EN = 1'd1 ;

  // register handle_count_tdi
  assign handle_count_tdi$D_IN = handle_count_tdi + 32'd1 ;
  assign handle_count_tdi$EN = handle_shift_dr || handle_shift_ir ;

  // register handle_count_tms
  assign handle_count_tms$D_IN = handle_count_tms + 32'd1 ;
  assign handle_count_tms$EN = 1'd1 ;

  // register handle_dba
  assign handle_dba$D_IN =
	     handle_shift_dr ?
	       temp_dba___1__h9222 :
	       (handle_capture_dr ? handle_latch_dba : 50'd0) ;
  assign handle_dba$EN =
	     (handle_test_logic_reset || handle_capture_dr ||
	      handle_shift_dr) &&
	     handle_latch_ir == 5'd17 ;

  // register handle_dba_tdo
  assign handle_dba_tdo$D_IN = handle_dba[0] ;
  assign handle_dba_tdo$EN = 1'd1 ;

  // register handle_debug_select
  assign handle_debug_select$D_IN = 1'b0 ;
  assign handle_debug_select$EN = 1'b0 ;

  // register handle_dtm_control
  assign handle_dtm_control$D_IN =
	     handle_shift_dr ?
	       temp_dtm___1__h9379 :
	       (handle_capture_dr ? handle_latch_dtm_control : 32'd0) ;
  assign handle_dtm_control$EN =
	     (handle_test_logic_reset || handle_capture_dr ||
	      handle_shift_dr) &&
	     handle_latch_ir == 5'd16 ;

  // register handle_dtm_control_tdo
  assign handle_dtm_control_tdo$D_IN = handle_dtm_control[0] ;
  assign handle_dtm_control_tdo$EN = 1'd1 ;

  // register handle_exit1_dr
  assign handle_exit1_dr$D_IN = MUX_handle_exit1_dr$write_1__SEL_1 ;
  assign handle_exit1_dr$EN =
	     (handle_shift_dr || handle_capture_dr) && handle_tms ||
	     handle_exit1_dr ;

  // register handle_exit1_ir
  assign handle_exit1_ir$D_IN = MUX_handle_exit1_ir$write_1__SEL_1 ;
  assign handle_exit1_ir$EN =
	     handle_shift_ir && handle_tms || handle_exit1_ir ;

  // register handle_exit2_dr
  assign handle_exit2_dr$D_IN = MUX_handle_exit2_dr$write_1__SEL_1 ;
  assign handle_exit2_dr$EN =
	     handle_pause_dr && handle_tms || handle_exit2_dr ;

  // register handle_exit2_ir
  assign handle_exit2_ir$D_IN = MUX_handle_exit2_ir$write_1__SEL_1 ;
  assign handle_exit2_ir$EN =
	     (handle_pause_ir || handle_capture_ir) && handle_tms ||
	     handle_exit2_ir ;

  // register handle_extest_select
  assign handle_extest_select$D_IN = 1'b0 ;
  assign handle_extest_select$EN = 1'b0 ;

  // register handle_idcode
  assign handle_idcode$D_IN =
	     handle_shift_dr ?
	       temp_idcode___1__h9597 :
	       (handle_capture_dr ? handle_latch_idcode : 32'd0) ;
  assign handle_idcode$EN =
	     (handle_test_logic_reset || handle_capture_dr ||
	      handle_shift_dr) &&
	     handle_latch_ir == 5'd1 ;

  // register handle_idcode_select
  assign handle_idcode_select$D_IN = 1'b0 ;
  assign handle_idcode_select$EN = 1'b0 ;

  // register handle_idcode_tdo
  assign handle_idcode_tdo$D_IN = handle_idcode[0] ;
  assign handle_idcode_tdo$EN = 1'd1 ;

  // register handle_instr_tdo
  assign handle_instr_tdo$D_IN = handle_instruction[0] ;
  assign handle_instr_tdo$EN = 1'd1 ;

  // register handle_instruction
  assign handle_instruction$D_IN =
	     handle_shift_ir ?
	       temp___1__h8879 :
	       (handle_capture_ir ? 5'b10101 : 5'd0) ;
  assign handle_instruction$EN =
	     handle_test_logic_reset || handle_capture_ir || handle_shift_ir ;

  // register handle_latch_bypass
  assign handle_latch_bypass$D_IN = handle_bypass ;
  assign handle_latch_bypass$EN =
	     handle_update_dr && handle_latch_ir == 5'd31 ;

  // register handle_latch_command
  assign handle_latch_command$D_IN = handle_command ;
  assign handle_latch_command$EN =
	     handle_update_dr && handle_latch_ir == 5'd18 ;

  // register handle_latch_dba
  assign handle_latch_dba$D_IN = handle_dba ;
  assign handle_latch_dba$EN = handle_update_dr && handle_latch_ir == 5'd17 ;

  // register handle_latch_dtm_control
  assign handle_latch_dtm_control$D_IN = handle_dtm_control ;
  assign handle_latch_dtm_control$EN =
	     handle_update_dr && handle_latch_ir == 5'd16 ;

  // register handle_latch_idcode
  assign handle_latch_idcode$D_IN = handle_idcode ;
  assign handle_latch_idcode$EN =
	     handle_update_dr && handle_latch_ir == 5'd1 ;

  // register handle_latch_ir
  assign handle_latch_ir$D_IN =
	     handle_update_ir ?
	       handle_instruction :
	       (handle_test_logic_reset ? 5'd10 : 5'd0) ;
  assign handle_latch_ir$EN = handle_test_logic_reset || handle_update_ir ;

  // register handle_pause_dr
  assign handle_pause_dr$D_IN = !MUX_handle_exit2_dr$write_1__SEL_1 ;
  assign handle_pause_dr$EN =
	     handle_pause_dr && handle_tms || handle_exit1_dr && !handle_tms ;

  // register handle_pause_ir
  assign handle_pause_ir$D_IN = !MUX_handle_pause_ir$write_1__SEL_1 ;
  assign handle_pause_ir$EN =
	     handle_pause_ir && handle_tms || handle_exit1_ir && !handle_tms ;

  // register handle_run_test_idle
  assign handle_run_test_idle$D_IN =
	     !MUX_handle_run_test_idle$write_1__SEL_1 ;
  assign handle_run_test_idle$EN =
	     handle_run_test_idle && handle_tms ||
	     (handle_update_ir || handle_update_dr ||
	      handle_test_logic_reset) &&
	     !handle_tms ;

  // register handle_sample_preload_select
  assign handle_sample_preload_select$D_IN = 1'b0 ;
  assign handle_sample_preload_select$EN = 1'b0 ;

  // register handle_select_dr_scan
  assign handle_select_dr_scan$D_IN =
	     MUX_handle_select_dr_scan$write_1__SEL_1 ;
  assign handle_select_dr_scan$EN =
	     (handle_update_ir || handle_update_dr || handle_run_test_idle) &&
	     handle_tms ||
	     handle_select_dr_scan ;

  // register handle_select_ir_scan
  assign handle_select_ir_scan$D_IN =
	     MUX_handle_select_ir_scan$write_1__SEL_1 ;
  assign handle_select_ir_scan$EN =
	     handle_select_dr_scan && handle_tms || handle_select_ir_scan ;

  // register handle_shift_dr
  assign handle_shift_dr$D_IN = !MUX_handle_shift_dr$write_1__SEL_1 ;
  assign handle_shift_dr$EN =
	     handle_shift_dr && handle_tms ||
	     (handle_exit2_dr || handle_capture_dr) && !handle_tms ;

  // register handle_shift_ir
  assign handle_shift_ir$D_IN = !MUX_handle_exit1_ir$write_1__SEL_1 ;
  assign handle_shift_ir$EN =
	     handle_shift_ir && handle_tms ||
	     (handle_exit2_ir || handle_capture_ir) && !handle_tms ;

  // register handle_shift_ir_neg
  assign handle_shift_ir_neg$D_IN = 1'b0 ;
  assign handle_shift_ir_neg$EN = 1'b0 ;

  // register handle_state
  always@(MUX_handle_state$write_1__SEL_1 or
	  WILL_FIRE_RL_handle_rl_buffer1 or WILL_FIRE_RL_handle_rl_buffer2)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_handle_state$write_1__SEL_1: handle_state$D_IN = 32'd0;
      WILL_FIRE_RL_handle_rl_buffer1: handle_state$D_IN = 32'd1;
      WILL_FIRE_RL_handle_rl_buffer2: handle_state$D_IN = 32'd2;
      default: handle_state$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign handle_state$EN =
	     WILL_FIRE_RL_rl_take_args || WILL_FIRE_RL_rl_take_cmd ||
	     WILL_FIRE_RL_handle_rl_buffer1 ||
	     WILL_FIRE_RL_handle_rl_buffer2 ;

  // register handle_tdi
  assign handle_tdi$D_IN = handle_tdi_vec[handle_count_tdi[5:0]] ;
  assign handle_tdi$EN = handle_shift_dr || handle_shift_ir ;

  // register handle_tdi_vec
  assign handle_tdi_vec$D_IN = 36'h0 ;
  assign handle_tdi_vec$EN = 1'b0 ;

  // register handle_tdo
  always@(handle_latch_ir or
	  handle_bypass_tdo or
	  handle_idcode_tdo or
	  handle_dtm_control_tdo or handle_dba_tdo or handle_command_tdo)
  begin
    case (handle_latch_ir)
      5'd1: handle_tdo$D_IN = handle_idcode_tdo;
      5'd16: handle_tdo$D_IN = handle_dtm_control_tdo;
      5'd17: handle_tdo$D_IN = handle_dba_tdo;
      5'd18: handle_tdo$D_IN = handle_command_tdo;
      default: handle_tdo$D_IN = handle_bypass_tdo;
    endcase
  end
  assign handle_tdo$EN = 1'd1 ;

  // register handle_tdo_enable
  assign handle_tdo_enable$D_IN = 1'b0 ;
  assign handle_tdo_enable$EN = 1'b0 ;

  // register handle_test_logic_reset
  assign handle_test_logic_reset$D_IN =
	     MUX_handle_test_logic_reset$write_1__SEL_1 ;
  assign handle_test_logic_reset$EN =
	     handle_select_ir_scan && handle_tms ||
	     handle_test_logic_reset && !handle_tms ;

  // register handle_tms
  assign handle_tms$D_IN = handle_tms_vec[handle_count_tms[5:0]] ;
  assign handle_tms$EN = CAN_FIRE_RL_handle_rl_tp ;

  // register handle_tms_vec
  assign handle_tms_vec$D_IN = 48'h0 ;
  assign handle_tms_vec$EN = 1'b0 ;

  // register handle_update_dr
  assign handle_update_dr$D_IN = MUX_handle_update_dr$write_1__SEL_1 ;
  assign handle_update_dr$EN =
	     (handle_exit2_dr || handle_exit1_dr) && handle_tms ||
	     handle_update_dr ;

  // register handle_update_ir
  assign handle_update_ir$D_IN = MUX_handle_update_ir$write_1__SEL_1 ;
  assign handle_update_ir$EN =
	     (handle_exit2_ir || handle_exit1_ir) && handle_tms ||
	     handle_update_ir ;

  // register hartinfo
  assign hartinfo$D_IN = 32'h0 ;
  assign hartinfo$EN = 1'b0 ;

  // register num_args
  always@(fifo_cmd$D_OUT)
  begin
    case (fifo_cmd$D_OUT[7:0])
      8'b00000001, 8'b00000010: num_args$D_IN = 32'd0;
      default: num_args$D_IN = 32'd1;
    endcase
  end
  assign num_args$EN = MUX_flag$write_1__SEL_1 ;

  // register read_data
  assign read_data$D_IN = 32'h0 ;
  assign read_data$EN = 1'b0 ;

  // register read_data_flag
  assign read_data_flag$D_IN = MUX_read_data_flag$write_1__SEL_1 ;
  assign read_data_flag$EN =
	     WILL_FIRE_RL_rl_dba_type && dba[1:0] == 2'd1 || read_data_flag ;

  // register ready_read
  assign ready_read$D_IN = !MUX_read_data_flag$write_1__SEL_1 ;
  assign ready_read$EN =
	     WILL_FIRE_RL_rl_dba_type && dba[1:0] == 2'd1 || read_data_flag ;

  // register rg_cmd
  always@(fifo_cmd$D_OUT)
  begin
    case (fifo_cmd$D_OUT[7:0])
      8'b00000001, 8'b00000010, 8'b00000011:
	  rg_cmd$D_IN = fifo_cmd$D_OUT[7:0];
      default: rg_cmd$D_IN = 8'd4;
    endcase
  end
  assign rg_cmd$EN = MUX_flag$write_1__SEL_1 ;

  // register write_data_flag
  assign write_data_flag$D_IN = MUX_write_data_flag$write_1__SEL_1 ;
  assign write_data_flag$EN =
	     WILL_FIRE_RL_rl_dba_type && dba[1:0] == 2'd2 || write_data_flag ;

  // submodule fifo_args
  assign fifo_args$D_IN = 32'h0 ;
  assign fifo_args$ENQ = 1'b0 ;
  assign fifo_args$DEQ = 1'b0 ;
  assign fifo_args$CLR = 1'b0 ;

  // submodule fifo_cmd
  assign fifo_cmd$D_IN = handle_latch_command ;
  assign fifo_cmd$ENQ = CAN_FIRE_RL_rl_take_cmd ;
  assign fifo_cmd$DEQ = CAN_FIRE_RL_rl_understand_cmd ;
  assign fifo_cmd$CLR = 1'b0 ;

  // submodule handle_fifo_bypass
  assign handle_fifo_bypass$D_IN = 1'b0 ;
  assign handle_fifo_bypass$ENQ = 1'b0 ;
  assign handle_fifo_bypass$DEQ = 1'b0 ;
  assign handle_fifo_bypass$CLR = 1'b0 ;

  // submodule handle_fifo_cmd
  assign handle_fifo_cmd$D_IN = 32'h0 ;
  assign handle_fifo_cmd$ENQ = 1'b0 ;
  assign handle_fifo_cmd$DEQ = 1'b0 ;
  assign handle_fifo_cmd$CLR = 1'b0 ;

  // submodule handle_fifo_dba
  assign handle_fifo_dba$D_IN = 50'h0 ;
  assign handle_fifo_dba$ENQ = 1'b0 ;
  assign handle_fifo_dba$DEQ = 1'b0 ;
  assign handle_fifo_dba$CLR = 1'b0 ;

  // submodule handle_fifo_dtm
  assign handle_fifo_dtm$D_IN = 32'h0 ;
  assign handle_fifo_dtm$ENQ = 1'b0 ;
  assign handle_fifo_dtm$DEQ = 1'b0 ;
  assign handle_fifo_dtm$CLR = 1'b0 ;

  // submodule handle_fifo_idcode
  assign handle_fifo_idcode$D_IN = 32'h0 ;
  assign handle_fifo_idcode$ENQ = 1'b0 ;
  assign handle_fifo_idcode$DEQ = 1'b0 ;
  assign handle_fifo_idcode$CLR = 1'b0 ;

  // remaining internal signals
  assign count_74_EQ_num_args_75___d213 = count == num_args ;
  assign temp___1__h8879 = { handle_tdi, handle_instruction[4:1] } ;
  assign temp_command___1__h9065 = { handle_tdi, handle_command[31:1] } ;
  assign temp_dba___1__h9222 = { handle_tdi, handle_dba[49:1] } ;
  assign temp_dtm___1__h9379 = { handle_tdi, handle_dtm_control[31:1] } ;
  assign temp_idcode___1__h9597 = { handle_tdi, handle_idcode[31:1] } ;
  assign v__h10833 =
	     { 1'd1,
	       dmcontrol[30:26],
	       fifo_cmd$D_OUT[17:8],
	       dmcontrol[15:0] } ;
  assign v__h11074 =
	     { dmcontrol[31],
	       1'd1,
	       dmcontrol[29:26],
	       fifo_cmd$D_OUT[17:8],
	       dmcontrol[15:0] } ;
  assign v__h11542 =
	     { dmcontrol[31:26], fifo_cmd$D_OUT[17:8], dmcontrol[15:0] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        abstractcs <= `BSV_ASSIGNMENT_DELAY 32'd0;
	address <= `BSV_ASSIGNMENT_DELAY 16'd0;
	args_present <= `BSV_ASSIGNMENT_DELAY 1'd0;
	command <= `BSV_ASSIGNMENT_DELAY 32'd0;
	count <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_10 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_11 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_3 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_4 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_5 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_6 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_7 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_8 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	data_9 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dba <= `BSV_ASSIGNMENT_DELAY 50'd0;
	dmcontrol <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dmstatus <= `BSV_ASSIGNMENT_DELAY 32'd0;
	flag <= `BSV_ASSIGNMENT_DELAY 32'd0;
	handle_bypass <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_bypass_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_capture_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_capture_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_command <= `BSV_ASSIGNMENT_DELAY 32'd0;
	handle_command_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_count_tdi <= `BSV_ASSIGNMENT_DELAY 32'd0;
	handle_count_tms <= `BSV_ASSIGNMENT_DELAY 32'd0;
	handle_dba <= `BSV_ASSIGNMENT_DELAY 50'd0;
	handle_debug_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_dtm_control <= `BSV_ASSIGNMENT_DELAY 32'd0;
	handle_exit1_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_exit1_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_exit2_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_exit2_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_extest_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_idcode <= `BSV_ASSIGNMENT_DELAY 32'd0;
	handle_idcode_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_instruction <= `BSV_ASSIGNMENT_DELAY 5'd0;
	handle_pause_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_pause_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_run_test_idle <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_sample_preload_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_select_dr_scan <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_select_ir_scan <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_shift_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_shift_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_state <= `BSV_ASSIGNMENT_DELAY 32'd0;
	handle_tdi <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_tdi_vec <= `BSV_ASSIGNMENT_DELAY
	    36'b000000000000000000000010000000011001;
	handle_test_logic_reset <= `BSV_ASSIGNMENT_DELAY 1'd1;
	handle_tms_vec <= `BSV_ASSIGNMENT_DELAY 48'h600000000E06;
	handle_update_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	handle_update_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	hartinfo <= `BSV_ASSIGNMENT_DELAY 32'd0;
	num_args <= `BSV_ASSIGNMENT_DELAY 32'd0;
	read_data <= `BSV_ASSIGNMENT_DELAY 32'd0;
	read_data_flag <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ready_read <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_cmd <= `BSV_ASSIGNMENT_DELAY 8'd0;
	write_data_flag <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (abstractcs$EN)
	  abstractcs <= `BSV_ASSIGNMENT_DELAY abstractcs$D_IN;
	if (address$EN) address <= `BSV_ASSIGNMENT_DELAY address$D_IN;
	if (args_present$EN)
	  args_present <= `BSV_ASSIGNMENT_DELAY args_present$D_IN;
	if (command$EN) command <= `BSV_ASSIGNMENT_DELAY command$D_IN;
	if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (data_0$EN) data_0 <= `BSV_ASSIGNMENT_DELAY data_0$D_IN;
	if (data_1$EN) data_1 <= `BSV_ASSIGNMENT_DELAY data_1$D_IN;
	if (data_10$EN) data_10 <= `BSV_ASSIGNMENT_DELAY data_10$D_IN;
	if (data_11$EN) data_11 <= `BSV_ASSIGNMENT_DELAY data_11$D_IN;
	if (data_2$EN) data_2 <= `BSV_ASSIGNMENT_DELAY data_2$D_IN;
	if (data_3$EN) data_3 <= `BSV_ASSIGNMENT_DELAY data_3$D_IN;
	if (data_4$EN) data_4 <= `BSV_ASSIGNMENT_DELAY data_4$D_IN;
	if (data_5$EN) data_5 <= `BSV_ASSIGNMENT_DELAY data_5$D_IN;
	if (data_6$EN) data_6 <= `BSV_ASSIGNMENT_DELAY data_6$D_IN;
	if (data_7$EN) data_7 <= `BSV_ASSIGNMENT_DELAY data_7$D_IN;
	if (data_8$EN) data_8 <= `BSV_ASSIGNMENT_DELAY data_8$D_IN;
	if (data_9$EN) data_9 <= `BSV_ASSIGNMENT_DELAY data_9$D_IN;
	if (dba$EN) dba <= `BSV_ASSIGNMENT_DELAY dba$D_IN;
	if (dmcontrol$EN) dmcontrol <= `BSV_ASSIGNMENT_DELAY dmcontrol$D_IN;
	if (dmstatus$EN) dmstatus <= `BSV_ASSIGNMENT_DELAY dmstatus$D_IN;
	if (flag$EN) flag <= `BSV_ASSIGNMENT_DELAY flag$D_IN;
	if (handle_bypass$EN)
	  handle_bypass <= `BSV_ASSIGNMENT_DELAY handle_bypass$D_IN;
	if (handle_bypass_select$EN)
	  handle_bypass_select <= `BSV_ASSIGNMENT_DELAY
	      handle_bypass_select$D_IN;
	if (handle_capture_dr$EN)
	  handle_capture_dr <= `BSV_ASSIGNMENT_DELAY handle_capture_dr$D_IN;
	if (handle_capture_ir$EN)
	  handle_capture_ir <= `BSV_ASSIGNMENT_DELAY handle_capture_ir$D_IN;
	if (handle_command$EN)
	  handle_command <= `BSV_ASSIGNMENT_DELAY handle_command$D_IN;
	if (handle_command_select$EN)
	  handle_command_select <= `BSV_ASSIGNMENT_DELAY
	      handle_command_select$D_IN;
	if (handle_count_tdi$EN)
	  handle_count_tdi <= `BSV_ASSIGNMENT_DELAY handle_count_tdi$D_IN;
	if (handle_count_tms$EN)
	  handle_count_tms <= `BSV_ASSIGNMENT_DELAY handle_count_tms$D_IN;
	if (handle_dba$EN)
	  handle_dba <= `BSV_ASSIGNMENT_DELAY handle_dba$D_IN;
	if (handle_debug_select$EN)
	  handle_debug_select <= `BSV_ASSIGNMENT_DELAY
	      handle_debug_select$D_IN;
	if (handle_dtm_control$EN)
	  handle_dtm_control <= `BSV_ASSIGNMENT_DELAY handle_dtm_control$D_IN;
	if (handle_exit1_dr$EN)
	  handle_exit1_dr <= `BSV_ASSIGNMENT_DELAY handle_exit1_dr$D_IN;
	if (handle_exit1_ir$EN)
	  handle_exit1_ir <= `BSV_ASSIGNMENT_DELAY handle_exit1_ir$D_IN;
	if (handle_exit2_dr$EN)
	  handle_exit2_dr <= `BSV_ASSIGNMENT_DELAY handle_exit2_dr$D_IN;
	if (handle_exit2_ir$EN)
	  handle_exit2_ir <= `BSV_ASSIGNMENT_DELAY handle_exit2_ir$D_IN;
	if (handle_extest_select$EN)
	  handle_extest_select <= `BSV_ASSIGNMENT_DELAY
	      handle_extest_select$D_IN;
	if (handle_idcode$EN)
	  handle_idcode <= `BSV_ASSIGNMENT_DELAY handle_idcode$D_IN;
	if (handle_idcode_select$EN)
	  handle_idcode_select <= `BSV_ASSIGNMENT_DELAY
	      handle_idcode_select$D_IN;
	if (handle_instruction$EN)
	  handle_instruction <= `BSV_ASSIGNMENT_DELAY handle_instruction$D_IN;
	if (handle_pause_dr$EN)
	  handle_pause_dr <= `BSV_ASSIGNMENT_DELAY handle_pause_dr$D_IN;
	if (handle_pause_ir$EN)
	  handle_pause_ir <= `BSV_ASSIGNMENT_DELAY handle_pause_ir$D_IN;
	if (handle_run_test_idle$EN)
	  handle_run_test_idle <= `BSV_ASSIGNMENT_DELAY
	      handle_run_test_idle$D_IN;
	if (handle_sample_preload_select$EN)
	  handle_sample_preload_select <= `BSV_ASSIGNMENT_DELAY
	      handle_sample_preload_select$D_IN;
	if (handle_select_dr_scan$EN)
	  handle_select_dr_scan <= `BSV_ASSIGNMENT_DELAY
	      handle_select_dr_scan$D_IN;
	if (handle_select_ir_scan$EN)
	  handle_select_ir_scan <= `BSV_ASSIGNMENT_DELAY
	      handle_select_ir_scan$D_IN;
	if (handle_shift_dr$EN)
	  handle_shift_dr <= `BSV_ASSIGNMENT_DELAY handle_shift_dr$D_IN;
	if (handle_shift_ir$EN)
	  handle_shift_ir <= `BSV_ASSIGNMENT_DELAY handle_shift_ir$D_IN;
	if (handle_state$EN)
	  handle_state <= `BSV_ASSIGNMENT_DELAY handle_state$D_IN;
	if (handle_tdi$EN)
	  handle_tdi <= `BSV_ASSIGNMENT_DELAY handle_tdi$D_IN;
	if (handle_tdi_vec$EN)
	  handle_tdi_vec <= `BSV_ASSIGNMENT_DELAY handle_tdi_vec$D_IN;
	if (handle_test_logic_reset$EN)
	  handle_test_logic_reset <= `BSV_ASSIGNMENT_DELAY
	      handle_test_logic_reset$D_IN;
	if (handle_tms_vec$EN)
	  handle_tms_vec <= `BSV_ASSIGNMENT_DELAY handle_tms_vec$D_IN;
	if (handle_update_dr$EN)
	  handle_update_dr <= `BSV_ASSIGNMENT_DELAY handle_update_dr$D_IN;
	if (handle_update_ir$EN)
	  handle_update_ir <= `BSV_ASSIGNMENT_DELAY handle_update_ir$D_IN;
	if (hartinfo$EN) hartinfo <= `BSV_ASSIGNMENT_DELAY hartinfo$D_IN;
	if (num_args$EN) num_args <= `BSV_ASSIGNMENT_DELAY num_args$D_IN;
	if (read_data$EN) read_data <= `BSV_ASSIGNMENT_DELAY read_data$D_IN;
	if (read_data_flag$EN)
	  read_data_flag <= `BSV_ASSIGNMENT_DELAY read_data_flag$D_IN;
	if (ready_read$EN)
	  ready_read <= `BSV_ASSIGNMENT_DELAY ready_read$D_IN;
	if (rg_cmd$EN) rg_cmd <= `BSV_ASSIGNMENT_DELAY rg_cmd$D_IN;
	if (write_data_flag$EN)
	  write_data_flag <= `BSV_ASSIGNMENT_DELAY write_data_flag$D_IN;
      end
  end

  always@(posedge handle_inverted$CLK_OUT)
  begin
    if (handle_bypass_tdo$EN)
      handle_bypass_tdo <= `BSV_ASSIGNMENT_DELAY handle_bypass_tdo$D_IN;
    if (handle_command_tdo$EN)
      handle_command_tdo <= `BSV_ASSIGNMENT_DELAY handle_command_tdo$D_IN;
    if (handle_dba_tdo$EN)
      handle_dba_tdo <= `BSV_ASSIGNMENT_DELAY handle_dba_tdo$D_IN;
    if (handle_dtm_control_tdo$EN)
      handle_dtm_control_tdo <= `BSV_ASSIGNMENT_DELAY
	  handle_dtm_control_tdo$D_IN;
    if (handle_idcode_tdo$EN)
      handle_idcode_tdo <= `BSV_ASSIGNMENT_DELAY handle_idcode_tdo$D_IN;
    if (handle_instr_tdo$EN)
      handle_instr_tdo <= `BSV_ASSIGNMENT_DELAY handle_instr_tdo$D_IN;
    if (handle_latch_bypass$EN)
      handle_latch_bypass <= `BSV_ASSIGNMENT_DELAY handle_latch_bypass$D_IN;
    if (handle_latch_command$EN)
      handle_latch_command <= `BSV_ASSIGNMENT_DELAY handle_latch_command$D_IN;
    if (handle_latch_dba$EN)
      handle_latch_dba <= `BSV_ASSIGNMENT_DELAY handle_latch_dba$D_IN;
    if (handle_latch_dtm_control$EN)
      handle_latch_dtm_control <= `BSV_ASSIGNMENT_DELAY
	  handle_latch_dtm_control$D_IN;
    if (handle_latch_idcode$EN)
      handle_latch_idcode <= `BSV_ASSIGNMENT_DELAY handle_latch_idcode$D_IN;
    if (handle_latch_ir$EN)
      handle_latch_ir <= `BSV_ASSIGNMENT_DELAY handle_latch_ir$D_IN;
    if (handle_shift_ir_neg$EN)
      handle_shift_ir_neg <= `BSV_ASSIGNMENT_DELAY handle_shift_ir_neg$D_IN;
    if (handle_tdo$EN) handle_tdo <= `BSV_ASSIGNMENT_DELAY handle_tdo$D_IN;
    if (handle_tdo_enable$EN)
      handle_tdo_enable <= `BSV_ASSIGNMENT_DELAY handle_tdo_enable$D_IN;
    if (handle_tms$EN) handle_tms <= `BSV_ASSIGNMENT_DELAY handle_tms$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    abstractcs = 32'hAAAAAAAA;
    address = 16'hAAAA;
    args_present = 1'h0;
    command = 32'hAAAAAAAA;
    count = 32'hAAAAAAAA;
    data_0 = 32'hAAAAAAAA;
    data_1 = 32'hAAAAAAAA;
    data_10 = 32'hAAAAAAAA;
    data_11 = 32'hAAAAAAAA;
    data_2 = 32'hAAAAAAAA;
    data_3 = 32'hAAAAAAAA;
    data_4 = 32'hAAAAAAAA;
    data_5 = 32'hAAAAAAAA;
    data_6 = 32'hAAAAAAAA;
    data_7 = 32'hAAAAAAAA;
    data_8 = 32'hAAAAAAAA;
    data_9 = 32'hAAAAAAAA;
    dba = 50'h2AAAAAAAAAAAA;
    dmcontrol = 32'hAAAAAAAA;
    dmstatus = 32'hAAAAAAAA;
    flag = 32'hAAAAAAAA;
    handle_bypass = 1'h0;
    handle_bypass_select = 1'h0;
    handle_bypass_tdo = 1'h0;
    handle_capture_dr = 1'h0;
    handle_capture_ir = 1'h0;
    handle_command = 32'hAAAAAAAA;
    handle_command_select = 1'h0;
    handle_command_tdo = 1'h0;
    handle_count_tdi = 32'hAAAAAAAA;
    handle_count_tms = 32'hAAAAAAAA;
    handle_dba = 50'h2AAAAAAAAAAAA;
    handle_dba_tdo = 1'h0;
    handle_debug_select = 1'h0;
    handle_dtm_control = 32'hAAAAAAAA;
    handle_dtm_control_tdo = 1'h0;
    handle_exit1_dr = 1'h0;
    handle_exit1_ir = 1'h0;
    handle_exit2_dr = 1'h0;
    handle_exit2_ir = 1'h0;
    handle_extest_select = 1'h0;
    handle_idcode = 32'hAAAAAAAA;
    handle_idcode_select = 1'h0;
    handle_idcode_tdo = 1'h0;
    handle_instr_tdo = 1'h0;
    handle_instruction = 5'h0A;
    handle_latch_bypass = 1'h0;
    handle_latch_command = 32'hAAAAAAAA;
    handle_latch_dba = 50'h2AAAAAAAAAAAA;
    handle_latch_dtm_control = 32'hAAAAAAAA;
    handle_latch_idcode = 32'hAAAAAAAA;
    handle_latch_ir = 5'h0A;
    handle_pause_dr = 1'h0;
    handle_pause_ir = 1'h0;
    handle_run_test_idle = 1'h0;
    handle_sample_preload_select = 1'h0;
    handle_select_dr_scan = 1'h0;
    handle_select_ir_scan = 1'h0;
    handle_shift_dr = 1'h0;
    handle_shift_ir = 1'h0;
    handle_shift_ir_neg = 1'h0;
    handle_state = 32'hAAAAAAAA;
    handle_tdi = 1'h0;
    handle_tdi_vec = 36'hAAAAAAAAA;
    handle_tdo = 1'h0;
    handle_tdo_enable = 1'h0;
    handle_test_logic_reset = 1'h0;
    handle_tms = 1'h0;
    handle_tms_vec = 48'hAAAAAAAAAAAA;
    handle_update_dr = 1'h0;
    handle_update_ir = 1'h0;
    hartinfo = 32'hAAAAAAAA;
    num_args = 32'hAAAAAAAA;
    read_data = 32'hAAAAAAAA;
    read_data_flag = 1'h0;
    ready_read = 1'h0;
    rg_cmd = 8'hAA;
    write_data_flag = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE) if (read_data_flag) $display("hi there");
    if (RST_N != `BSV_RESET_VALUE)
      if (write_data_flag) $display("hi not there");
    if (RST_N != `BSV_RESET_VALUE) if (write_data_flag) $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_dba_type && dba[1:0] == 2'd0)
	$display("Bhaad me jao");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_print) $display("%d", dmcontrol);
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_rl_print) $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE) if (dmcontrol[31]) $display("hey there");
    if (RST_N != `BSV_RESET_VALUE)
      if (dmcontrol[30]) $display("hey not there");
    if (RST_N != `BSV_RESET_VALUE)
      $display("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
	       handle_test_logic_reset,
	       handle_run_test_idle,
	       handle_select_dr_scan,
	       handle_select_ir_scan,
	       handle_capture_dr,
	       handle_capture_ir,
	       handle_shift_dr,
	       handle_shift_ir,
	       handle_exit1_dr,
	       handle_exit1_ir,
	       handle_pause_dr,
	       handle_pause_ir,
	       handle_exit2_dr,
	       handle_exit2_ir,
	       handle_update_dr,
	       handle_update_ir);
    if (RST_N != `BSV_RESET_VALUE)
      $display("%d %d %d %d %d",
	       handle_instruction,
	       handle_latch_ir,
	       handle_bypass,
	       handle_dba,
	       handle_command,
	       handle_dtm_control);
    if (RST_N != `BSV_RESET_VALUE)
      $display("%d %d", handle_count_tdi, handle_tms);
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_update_dr && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 185: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_15] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit2_dr && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 173: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_14] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit2_dr && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 173: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_14] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_select_ir_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_4] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_select_dr_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_3] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_test_logic_reset && handle_run_test_idle)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_1] and\n  [RL_handle_rl_state_2] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_select_ir_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_4] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_run_test_idle && handle_select_dr_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_2] and\n  [RL_handle_rl_state_3] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_dr_scan && handle_select_ir_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_3] and\n  [RL_handle_rl_state_4] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_select_ir_scan && handle_capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_4] and\n  [RL_handle_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_dr && handle_capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_5] and\n  [RL_handle_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_capture_ir && handle_shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_6] and\n  [RL_handle_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_dr && handle_shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_7] and\n  [RL_handle_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_shift_ir && handle_exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_8] and\n  [RL_handle_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_dr && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_9] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_dr && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_9] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_dr && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_9] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_dr && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_9] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_dr && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_9] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_dr && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_9] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_dr && handle_exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_9] and\n  [RL_handle_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_ir && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_10] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_ir && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_10] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_ir && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_10] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_ir && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_10] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_ir && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_10] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit1_ir && handle_pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_10] and\n  [RL_handle_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_dr && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_11] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_dr && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_11] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_dr && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_11] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_dr && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_11] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_dr && handle_pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_11] and\n  [RL_handle_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_ir && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_12] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_ir && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_12] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_ir && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_12] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_pause_ir && handle_exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_12] and\n  [RL_handle_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit2_ir && handle_update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 161: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_13] and\n  [RL_handle_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit2_ir && handle_update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 161: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_13] and\n  [RL_handle_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (handle_exit2_ir && handle_exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 130, column 161: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_handle_rl_state_13] and\n  [RL_handle_rl_state_14] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on

  // synopsys translate_off
  always@(negedge handle_inverted$CLK_OUT)
  begin
    #0;
    if (handle_latch_ir == 5'd17) $display("hi");
  end
  // synopsys translate_on
endmodule  // mkDM_Interface

