//
// Generated by Bluespec Compiler, version 2017.03.beta1 (build 35049, 2017-03-16)
//
// On Tue Jun 20 12:03:53 IST 2017
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkJtag(CLK,
	      RST_N);
  input  CLK;
  input  RST_N;

  // register bypass
  reg bypass;
  wire bypass$D_IN, bypass$EN;

  // register bypass_select
  reg bypass_select;
  wire bypass_select$D_IN, bypass_select$EN;

  // register bypass_tdo
  reg bypass_tdo;
  wire bypass_tdo$D_IN, bypass_tdo$EN;

  // register capture_dr
  reg capture_dr;
  wire capture_dr$D_IN, capture_dr$EN;

  // register capture_ir
  reg capture_ir;
  wire capture_ir$D_IN, capture_ir$EN;

  // register count_tdi
  reg [4 : 0] count_tdi;
  wire [4 : 0] count_tdi$D_IN;
  wire count_tdi$EN;

  // register count_tms
  reg [4 : 0] count_tms;
  wire [4 : 0] count_tms$D_IN;
  wire count_tms$EN;

  // register dba
  reg [40 : 0] dba;
  wire [40 : 0] dba$D_IN;
  wire dba$EN;

  // register dba_tdo
  reg dba_tdo;
  wire dba_tdo$D_IN, dba_tdo$EN;

  // register debug_op
  reg debug_op;
  wire debug_op$D_IN, debug_op$EN;

  // register debug_select
  reg debug_select;
  wire debug_select$D_IN, debug_select$EN;

  // register dtm_control
  reg [31 : 0] dtm_control;
  wire [31 : 0] dtm_control$D_IN;
  wire dtm_control$EN;

  // register dtm_control_tdo
  reg dtm_control_tdo;
  wire dtm_control_tdo$D_IN, dtm_control_tdo$EN;

  // register exit1_dr
  reg exit1_dr;
  wire exit1_dr$D_IN, exit1_dr$EN;

  // register exit1_ir
  reg exit1_ir;
  wire exit1_ir$D_IN, exit1_ir$EN;

  // register exit2_dr
  reg exit2_dr;
  wire exit2_dr$D_IN, exit2_dr$EN;

  // register exit2_ir
  reg exit2_ir;
  wire exit2_ir$D_IN, exit2_ir$EN;

  // register extest_select
  reg extest_select;
  wire extest_select$D_IN, extest_select$EN;

  // register idcode
  reg [31 : 0] idcode;
  wire [31 : 0] idcode$D_IN;
  wire idcode$EN;

  // register idcode_select
  reg idcode_select;
  wire idcode_select$D_IN, idcode_select$EN;

  // register idcode_tdo
  reg idcode_tdo;
  wire idcode_tdo$D_IN, idcode_tdo$EN;

  // register instr_tdo
  reg instr_tdo;
  wire instr_tdo$D_IN, instr_tdo$EN;

  // register instruction
  reg [4 : 0] instruction;
  wire [4 : 0] instruction$D_IN;
  wire instruction$EN;

  // register latch_bypass
  reg latch_bypass;
  wire latch_bypass$D_IN, latch_bypass$EN;

  // register latch_dba
  reg [40 : 0] latch_dba;
  wire [40 : 0] latch_dba$D_IN;
  wire latch_dba$EN;

  // register latch_dtm_control
  reg [31 : 0] latch_dtm_control;
  wire [31 : 0] latch_dtm_control$D_IN;
  wire latch_dtm_control$EN;

  // register latch_idcode
  reg [31 : 0] latch_idcode;
  wire [31 : 0] latch_idcode$D_IN;
  wire latch_idcode$EN;

  // register latch_ir
  reg [4 : 0] latch_ir;
  wire [4 : 0] latch_ir$D_IN;
  wire latch_ir$EN;

  // register latch_ir_neg
  reg [4 : 0] latch_ir_neg;
  wire [4 : 0] latch_ir_neg$D_IN;
  wire latch_ir_neg$EN;

  // register pause_dr
  reg pause_dr;
  wire pause_dr$D_IN, pause_dr$EN;

  // register pause_ir
  reg pause_ir;
  wire pause_ir$D_IN, pause_ir$EN;

  // register run_test_idle
  reg run_test_idle;
  wire run_test_idle$D_IN, run_test_idle$EN;

  // register sample_preload_select
  reg sample_preload_select;
  wire sample_preload_select$D_IN, sample_preload_select$EN;

  // register scan_chain_op
  reg scan_chain_op;
  wire scan_chain_op$D_IN, scan_chain_op$EN;

  // register select_dr_scan
  reg select_dr_scan;
  wire select_dr_scan$D_IN, select_dr_scan$EN;

  // register select_ir_scan
  reg select_ir_scan;
  wire select_ir_scan$D_IN, select_ir_scan$EN;

  // register shift_dr
  reg shift_dr;
  wire shift_dr$D_IN, shift_dr$EN;

  // register shift_ir
  reg shift_ir;
  wire shift_ir$D_IN, shift_ir$EN;

  // register shift_ir_neg
  reg shift_ir_neg;
  wire shift_ir_neg$D_IN, shift_ir_neg$EN;

  // register tdi
  reg tdi;
  wire tdi$D_IN, tdi$EN;

  // register tdi_vec
  reg [8 : 0] tdi_vec;
  wire [8 : 0] tdi_vec$D_IN;
  wire tdi_vec$EN;

  // register tdo
  reg tdo;
  reg tdo$D_IN;
  wire tdo$EN;

  // register tdo_enable
  reg tdo_enable;
  wire tdo_enable$D_IN, tdo_enable$EN;

  // register test_logic_reset
  reg test_logic_reset;
  wire test_logic_reset$D_IN, test_logic_reset$EN;

  // register tms
  reg tms;
  wire tms$D_IN, tms$EN;

  // register tms_vec
  reg [20 : 0] tms_vec;
  wire [20 : 0] tms_vec$D_IN;
  wire tms_vec$EN;

  // register update_dr
  reg update_dr;
  wire update_dr$D_IN, update_dr$EN;

  // register update_ir
  reg update_ir;
  wire update_ir$D_IN, update_ir$EN;

  // ports of submodule inverted
  wire inverted$CLK_OUT;

  // rule scheduling signals
  wire CAN_FIRE_RL_cross_bypass_clock_domain_crossing,
       CAN_FIRE_RL_cross_count_tdi_clock_domain_crossing,
       CAN_FIRE_RL_cross_count_tms_clock_domain_crossing,
       CAN_FIRE_RL_cross_dba_clock_domain_crossing,
       CAN_FIRE_RL_cross_dtm_control_clock_domain_crossing,
       CAN_FIRE_RL_cross_idcode_clock_domain_crossing,
       CAN_FIRE_RL_cross_instruction_clock_domain_crossing,
       CAN_FIRE_RL_cross_latch_bypass_clock_domain_crossing,
       CAN_FIRE_RL_cross_latch_dba_clock_domain_crossing,
       CAN_FIRE_RL_cross_latch_dtm_control_clock_domain_crossing,
       CAN_FIRE_RL_cross_latch_idcode_clock_domain_crossing,
       CAN_FIRE_RL_cross_latch_ir_clock_domain_crossing,
       CAN_FIRE_RL_cross_shift_dr_clock_domain_crossing,
       CAN_FIRE_RL_cross_shift_ir_clock_domain_crossing,
       CAN_FIRE_RL_cross_tdi_clock_domain_crossing,
       CAN_FIRE_RL_cross_tdi_vec_clock_domain_crossing,
       CAN_FIRE_RL_cross_tdo_clock_domain_crossing,
       CAN_FIRE_RL_cross_test_logic_reset_clock_domain_crossing,
       CAN_FIRE_RL_cross_tms_clock_domain_crossing,
       CAN_FIRE_RL_cross_tms_vec_clock_domain_crossing,
       CAN_FIRE_RL_cross_update_dr_clock_domain_crossing,
       CAN_FIRE_RL_cross_update_ir_clock_domain_crossing,
       CAN_FIRE_RL_rl_assign_op,
       CAN_FIRE_RL_rl_data,
       CAN_FIRE_RL_rl_inc_count,
       CAN_FIRE_RL_rl_instruction,
       CAN_FIRE_RL_rl_print_state,
       CAN_FIRE_RL_rl_shift_out,
       CAN_FIRE_RL_rl_state_1,
       CAN_FIRE_RL_rl_state_10,
       CAN_FIRE_RL_rl_state_11,
       CAN_FIRE_RL_rl_state_12,
       CAN_FIRE_RL_rl_state_13,
       CAN_FIRE_RL_rl_state_14,
       CAN_FIRE_RL_rl_state_15,
       CAN_FIRE_RL_rl_state_16,
       CAN_FIRE_RL_rl_state_2,
       CAN_FIRE_RL_rl_state_3,
       CAN_FIRE_RL_rl_state_4,
       CAN_FIRE_RL_rl_state_5,
       CAN_FIRE_RL_rl_state_6,
       CAN_FIRE_RL_rl_state_7,
       CAN_FIRE_RL_rl_state_8,
       CAN_FIRE_RL_rl_state_9,
       CAN_FIRE_RL_rl_stop,
       CAN_FIRE_RL_rl_tp,
       CAN_FIRE_RL_rl_update_data,
       CAN_FIRE_RL_rl_update_ir,
       CAN_FIRE___me_check_22,
       CAN_FIRE___me_check_23,
       CAN_FIRE___me_check_24,
       CAN_FIRE___me_check_25,
       CAN_FIRE___me_check_26,
       CAN_FIRE___me_check_27,
       CAN_FIRE___me_check_28,
       CAN_FIRE___me_check_29,
       CAN_FIRE___me_check_30,
       CAN_FIRE___me_check_31,
       CAN_FIRE___me_check_32,
       CAN_FIRE___me_check_33,
       CAN_FIRE___me_check_34,
       CAN_FIRE___me_check_35,
       CAN_FIRE___me_check_36,
       WILL_FIRE_RL_cross_bypass_clock_domain_crossing,
       WILL_FIRE_RL_cross_count_tdi_clock_domain_crossing,
       WILL_FIRE_RL_cross_count_tms_clock_domain_crossing,
       WILL_FIRE_RL_cross_dba_clock_domain_crossing,
       WILL_FIRE_RL_cross_dtm_control_clock_domain_crossing,
       WILL_FIRE_RL_cross_idcode_clock_domain_crossing,
       WILL_FIRE_RL_cross_instruction_clock_domain_crossing,
       WILL_FIRE_RL_cross_latch_bypass_clock_domain_crossing,
       WILL_FIRE_RL_cross_latch_dba_clock_domain_crossing,
       WILL_FIRE_RL_cross_latch_dtm_control_clock_domain_crossing,
       WILL_FIRE_RL_cross_latch_idcode_clock_domain_crossing,
       WILL_FIRE_RL_cross_latch_ir_clock_domain_crossing,
       WILL_FIRE_RL_cross_shift_dr_clock_domain_crossing,
       WILL_FIRE_RL_cross_shift_ir_clock_domain_crossing,
       WILL_FIRE_RL_cross_tdi_clock_domain_crossing,
       WILL_FIRE_RL_cross_tdi_vec_clock_domain_crossing,
       WILL_FIRE_RL_cross_tdo_clock_domain_crossing,
       WILL_FIRE_RL_cross_test_logic_reset_clock_domain_crossing,
       WILL_FIRE_RL_cross_tms_clock_domain_crossing,
       WILL_FIRE_RL_cross_tms_vec_clock_domain_crossing,
       WILL_FIRE_RL_cross_update_dr_clock_domain_crossing,
       WILL_FIRE_RL_cross_update_ir_clock_domain_crossing,
       WILL_FIRE_RL_rl_assign_op,
       WILL_FIRE_RL_rl_data,
       WILL_FIRE_RL_rl_inc_count,
       WILL_FIRE_RL_rl_instruction,
       WILL_FIRE_RL_rl_print_state,
       WILL_FIRE_RL_rl_shift_out,
       WILL_FIRE_RL_rl_state_1,
       WILL_FIRE_RL_rl_state_10,
       WILL_FIRE_RL_rl_state_11,
       WILL_FIRE_RL_rl_state_12,
       WILL_FIRE_RL_rl_state_13,
       WILL_FIRE_RL_rl_state_14,
       WILL_FIRE_RL_rl_state_15,
       WILL_FIRE_RL_rl_state_16,
       WILL_FIRE_RL_rl_state_2,
       WILL_FIRE_RL_rl_state_3,
       WILL_FIRE_RL_rl_state_4,
       WILL_FIRE_RL_rl_state_5,
       WILL_FIRE_RL_rl_state_6,
       WILL_FIRE_RL_rl_state_7,
       WILL_FIRE_RL_rl_state_8,
       WILL_FIRE_RL_rl_state_9,
       WILL_FIRE_RL_rl_stop,
       WILL_FIRE_RL_rl_tp,
       WILL_FIRE_RL_rl_update_data,
       WILL_FIRE_RL_rl_update_ir,
       WILL_FIRE___me_check_22,
       WILL_FIRE___me_check_23,
       WILL_FIRE___me_check_24,
       WILL_FIRE___me_check_25,
       WILL_FIRE___me_check_26,
       WILL_FIRE___me_check_27,
       WILL_FIRE___me_check_28,
       WILL_FIRE___me_check_29,
       WILL_FIRE___me_check_30,
       WILL_FIRE___me_check_31,
       WILL_FIRE___me_check_32,
       WILL_FIRE___me_check_33,
       WILL_FIRE___me_check_34,
       WILL_FIRE___me_check_35,
       WILL_FIRE___me_check_36;

  // inputs to muxes for submodule ports
  wire MUX_capture_dr$write_1__SEL_1,
       MUX_capture_ir$write_1__SEL_1,
       MUX_exit1_dr$write_1__PSEL_1,
       MUX_exit1_dr$write_1__SEL_1,
       MUX_exit1_ir$write_1__SEL_1,
       MUX_exit2_dr$write_1__SEL_1,
       MUX_exit2_ir$write_1__PSEL_1,
       MUX_exit2_ir$write_1__SEL_1,
       MUX_pause_ir$write_1__SEL_1,
       MUX_run_test_idle$write_1__SEL_1,
       MUX_select_dr_scan$write_1__PSEL_1,
       MUX_select_dr_scan$write_1__SEL_1,
       MUX_select_ir_scan$write_1__SEL_1,
       MUX_shift_dr$write_1__SEL_1,
       MUX_test_logic_reset$write_1__SEL_1,
       MUX_update_dr$write_1__PSEL_1,
       MUX_update_dr$write_1__SEL_1,
       MUX_update_ir$write_1__PSEL_1,
       MUX_update_ir$write_1__SEL_1;

  // remaining internal signals
  wire [40 : 0] temp_dba___1__h6994;
  wire [31 : 0] temp_dtm___1__h7115, temp_idcode___1__h7292;
  wire [4 : 0] temp___1__h6801;

  // submodule inverted
  ClockInverter inverted(.CLK_IN(CLK),
			 .PREEDGE(),
			 .CLK_OUT(inverted$CLK_OUT));

  // rule RL_rl_print_state
  assign CAN_FIRE_RL_rl_print_state = 1'd1 ;
  assign WILL_FIRE_RL_rl_print_state = 1'd1 ;

  // rule RL_rl_state_2
  assign CAN_FIRE_RL_rl_state_2 = run_test_idle ;
  assign WILL_FIRE_RL_rl_state_2 = run_test_idle ;

  // rule RL_rl_state_11
  assign CAN_FIRE_RL_rl_state_11 = pause_dr ;
  assign WILL_FIRE_RL_rl_state_11 = pause_dr ;

  // rule RL_rl_state_12
  assign CAN_FIRE_RL_rl_state_12 = pause_ir ;
  assign WILL_FIRE_RL_rl_state_12 = pause_ir ;

  // rule RL_rl_stop
  assign CAN_FIRE_RL_rl_stop = count_tms == 5'd21 ;
  assign WILL_FIRE_RL_rl_stop = CAN_FIRE_RL_rl_stop ;

  // rule RL_cross_tms_clock_domain_crossing
  assign CAN_FIRE_RL_cross_tms_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_tms_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_tp
  assign CAN_FIRE_RL_rl_tp = count_tms < 5'd21 ;
  assign WILL_FIRE_RL_rl_tp = CAN_FIRE_RL_rl_tp ;

  // rule RL_cross_count_tms_clock_domain_crossing
  assign CAN_FIRE_RL_cross_count_tms_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_count_tms_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_tms_vec_clock_domain_crossing
  assign CAN_FIRE_RL_cross_tms_vec_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_tms_vec_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_cross_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_count_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_cross_count_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_count_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_tdi_vec_clock_domain_crossing
  assign CAN_FIRE_RL_cross_tdi_vec_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_tdi_vec_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_tdo_clock_domain_crossing
  assign CAN_FIRE_RL_cross_tdo_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_tdo_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_assign_op
  assign CAN_FIRE_RL_rl_assign_op = shift_ir || shift_dr ;
  assign WILL_FIRE_RL_rl_assign_op = CAN_FIRE_RL_rl_assign_op ;

  // rule RL_rl_shift_out
  assign CAN_FIRE_RL_rl_shift_out = 1'd1 ;
  assign WILL_FIRE_RL_rl_shift_out = 1'd1 ;

  // rule RL_cross_latch_dba_clock_domain_crossing
  assign CAN_FIRE_RL_cross_latch_dba_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_latch_dba_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_latch_dtm_control_clock_domain_crossing
  assign CAN_FIRE_RL_cross_latch_dtm_control_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_latch_dtm_control_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_latch_bypass_clock_domain_crossing
  assign CAN_FIRE_RL_cross_latch_bypass_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_latch_bypass_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_latch_idcode_clock_domain_crossing
  assign CAN_FIRE_RL_cross_latch_idcode_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_latch_idcode_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_update_data
  assign CAN_FIRE_RL_rl_update_data = 1'd1 ;
  assign WILL_FIRE_RL_rl_update_data = 1'd1 ;

  // rule RL_cross_latch_ir_clock_domain_crossing
  assign CAN_FIRE_RL_cross_latch_ir_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_latch_ir_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_update_ir
  assign CAN_FIRE_RL_rl_update_ir = 1'd1 ;
  assign WILL_FIRE_RL_rl_update_ir = 1'd1 ;

  // rule RL_cross_dba_clock_domain_crossing
  assign CAN_FIRE_RL_cross_dba_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_dba_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_dtm_control_clock_domain_crossing
  assign CAN_FIRE_RL_cross_dtm_control_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_dtm_control_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_bypass_clock_domain_crossing
  assign CAN_FIRE_RL_cross_bypass_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_bypass_clock_domain_crossing = 1'd1 ;

  // rule RL_cross_idcode_clock_domain_crossing
  assign CAN_FIRE_RL_cross_idcode_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_idcode_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_data
  assign CAN_FIRE_RL_rl_data = 1'd1 ;
  assign WILL_FIRE_RL_rl_data = 1'd1 ;

  // rule RL_rl_state_3
  assign CAN_FIRE_RL_rl_state_3 = select_dr_scan ;
  assign WILL_FIRE_RL_rl_state_3 = select_dr_scan ;

  // rule RL_cross_instruction_clock_domain_crossing
  assign CAN_FIRE_RL_cross_instruction_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_instruction_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_instruction
  assign CAN_FIRE_RL_rl_instruction = 1'd1 ;
  assign WILL_FIRE_RL_rl_instruction = 1'd1 ;

  // rule RL_rl_inc_count
  assign CAN_FIRE_RL_rl_inc_count = 1'd1 ;
  assign WILL_FIRE_RL_rl_inc_count = 1'd1 ;

  // rule RL_cross_update_dr_clock_domain_crossing
  assign CAN_FIRE_RL_cross_update_dr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_update_dr_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_state_9
  assign CAN_FIRE_RL_rl_state_9 = exit1_dr ;
  assign WILL_FIRE_RL_rl_state_9 = exit1_dr ;

  // rule RL_rl_state_15
  assign CAN_FIRE_RL_rl_state_15 = update_dr ;
  assign WILL_FIRE_RL_rl_state_15 = update_dr ;

  // rule RL_cross_update_ir_clock_domain_crossing
  assign CAN_FIRE_RL_cross_update_ir_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_update_ir_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_state_10
  assign CAN_FIRE_RL_rl_state_10 = exit1_ir ;
  assign WILL_FIRE_RL_rl_state_10 = exit1_ir ;

  // rule RL_rl_state_16
  assign CAN_FIRE_RL_rl_state_16 = update_ir ;
  assign WILL_FIRE_RL_rl_state_16 = update_ir ;

  // rule __me_check_36
  assign CAN_FIRE___me_check_36 = 1'b1 ;
  assign WILL_FIRE___me_check_36 = 1'b1 ;

  // rule RL_cross_test_logic_reset_clock_domain_crossing
  assign CAN_FIRE_RL_cross_test_logic_reset_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_test_logic_reset_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_state_1
  assign CAN_FIRE_RL_rl_state_1 = test_logic_reset ;
  assign WILL_FIRE_RL_rl_state_1 = test_logic_reset ;

  // rule RL_rl_state_4
  assign CAN_FIRE_RL_rl_state_4 = select_ir_scan ;
  assign WILL_FIRE_RL_rl_state_4 = select_ir_scan ;

  // rule RL_cross_shift_dr_clock_domain_crossing
  assign CAN_FIRE_RL_cross_shift_dr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_shift_dr_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_state_5
  assign CAN_FIRE_RL_rl_state_5 = capture_dr ;
  assign WILL_FIRE_RL_rl_state_5 = capture_dr ;

  // rule RL_rl_state_7
  assign CAN_FIRE_RL_rl_state_7 = shift_dr ;
  assign WILL_FIRE_RL_rl_state_7 = shift_dr ;

  // rule RL_rl_state_14
  assign CAN_FIRE_RL_rl_state_14 = exit2_dr ;
  assign WILL_FIRE_RL_rl_state_14 = exit2_dr ;

  // rule __me_check_35
  assign CAN_FIRE___me_check_35 = 1'b1 ;
  assign WILL_FIRE___me_check_35 = 1'b1 ;

  // rule RL_cross_shift_ir_clock_domain_crossing
  assign CAN_FIRE_RL_cross_shift_ir_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_cross_shift_ir_clock_domain_crossing = 1'd1 ;

  // rule RL_rl_state_6
  assign CAN_FIRE_RL_rl_state_6 = capture_ir ;
  assign WILL_FIRE_RL_rl_state_6 = capture_ir ;

  // rule RL_rl_state_8
  assign CAN_FIRE_RL_rl_state_8 = shift_ir ;
  assign WILL_FIRE_RL_rl_state_8 = shift_ir ;

  // rule RL_rl_state_13
  assign CAN_FIRE_RL_rl_state_13 = exit2_ir ;
  assign WILL_FIRE_RL_rl_state_13 = exit2_ir ;

  // rule __me_check_22
  assign CAN_FIRE___me_check_22 = 1'b1 ;
  assign WILL_FIRE___me_check_22 = 1'b1 ;

  // rule __me_check_23
  assign CAN_FIRE___me_check_23 = 1'b1 ;
  assign WILL_FIRE___me_check_23 = 1'b1 ;

  // rule __me_check_24
  assign CAN_FIRE___me_check_24 = 1'b1 ;
  assign WILL_FIRE___me_check_24 = 1'b1 ;

  // rule __me_check_25
  assign CAN_FIRE___me_check_25 = 1'b1 ;
  assign WILL_FIRE___me_check_25 = 1'b1 ;

  // rule __me_check_26
  assign CAN_FIRE___me_check_26 = 1'b1 ;
  assign WILL_FIRE___me_check_26 = 1'b1 ;

  // rule __me_check_27
  assign CAN_FIRE___me_check_27 = 1'b1 ;
  assign WILL_FIRE___me_check_27 = 1'b1 ;

  // rule __me_check_29
  assign CAN_FIRE___me_check_29 = 1'b1 ;
  assign WILL_FIRE___me_check_29 = 1'b1 ;

  // rule __me_check_28
  assign CAN_FIRE___me_check_28 = 1'b1 ;
  assign WILL_FIRE___me_check_28 = 1'b1 ;

  // rule __me_check_30
  assign CAN_FIRE___me_check_30 = 1'b1 ;
  assign WILL_FIRE___me_check_30 = 1'b1 ;

  // rule __me_check_31
  assign CAN_FIRE___me_check_31 = 1'b1 ;
  assign WILL_FIRE___me_check_31 = 1'b1 ;

  // rule __me_check_32
  assign CAN_FIRE___me_check_32 = 1'b1 ;
  assign WILL_FIRE___me_check_32 = 1'b1 ;

  // rule __me_check_33
  assign CAN_FIRE___me_check_33 = 1'b1 ;
  assign WILL_FIRE___me_check_33 = 1'b1 ;

  // rule __me_check_34
  assign CAN_FIRE___me_check_34 = 1'b1 ;
  assign WILL_FIRE___me_check_34 = 1'b1 ;

  // inputs to muxes for submodule ports
  assign MUX_capture_dr$write_1__SEL_1 = select_dr_scan && !tms ;
  assign MUX_capture_ir$write_1__SEL_1 = select_ir_scan && !tms ;
  assign MUX_exit1_dr$write_1__PSEL_1 = shift_dr || capture_dr ;
  assign MUX_exit1_dr$write_1__SEL_1 = MUX_exit1_dr$write_1__PSEL_1 && tms ;
  assign MUX_exit1_ir$write_1__SEL_1 = shift_ir && tms ;
  assign MUX_exit2_dr$write_1__SEL_1 = pause_dr && tms ;
  assign MUX_exit2_ir$write_1__PSEL_1 = pause_ir || capture_ir ;
  assign MUX_exit2_ir$write_1__SEL_1 = MUX_exit2_ir$write_1__PSEL_1 && tms ;
  assign MUX_pause_ir$write_1__SEL_1 = pause_ir && tms ;
  assign MUX_run_test_idle$write_1__SEL_1 = run_test_idle && tms ;
  assign MUX_select_dr_scan$write_1__PSEL_1 =
	     update_ir || update_dr || run_test_idle ;
  assign MUX_select_dr_scan$write_1__SEL_1 =
	     MUX_select_dr_scan$write_1__PSEL_1 && tms ;
  assign MUX_select_ir_scan$write_1__SEL_1 = select_dr_scan && tms ;
  assign MUX_shift_dr$write_1__SEL_1 = shift_dr && tms ;
  assign MUX_test_logic_reset$write_1__SEL_1 = select_ir_scan && tms ;
  assign MUX_update_dr$write_1__PSEL_1 = exit2_dr || exit1_dr ;
  assign MUX_update_dr$write_1__SEL_1 = MUX_update_dr$write_1__PSEL_1 && tms ;
  assign MUX_update_ir$write_1__PSEL_1 = exit2_ir || exit1_ir ;
  assign MUX_update_ir$write_1__SEL_1 = MUX_update_ir$write_1__PSEL_1 && tms ;

  // register bypass
  assign bypass$D_IN = shift_dr ? tdi : capture_dr && latch_bypass ;
  assign bypass$EN =
	     (test_logic_reset || capture_dr || shift_dr) &&
	     latch_ir == 5'd31 ;

  // register bypass_select
  assign bypass_select$D_IN = 1'b0 ;
  assign bypass_select$EN = 1'b0 ;

  // register bypass_tdo
  assign bypass_tdo$D_IN = bypass ;
  assign bypass_tdo$EN = 1'd1 ;

  // register capture_dr
  assign capture_dr$D_IN = MUX_capture_dr$write_1__SEL_1 ;
  assign capture_dr$EN = select_dr_scan && !tms || capture_dr ;

  // register capture_ir
  assign capture_ir$D_IN = MUX_capture_ir$write_1__SEL_1 ;
  assign capture_ir$EN = select_ir_scan && !tms || capture_ir ;

  // register count_tdi
  assign count_tdi$D_IN = count_tdi + 5'd1 ;
  assign count_tdi$EN = shift_dr || shift_ir ;

  // register count_tms
  assign count_tms$D_IN = count_tms + 5'd1 ;
  assign count_tms$EN = 1'd1 ;

  // register dba
  assign dba$D_IN =
	     shift_dr ?
	       temp_dba___1__h6994 :
	       (capture_dr ? latch_dba : 41'd0) ;
  assign dba$EN =
	     (test_logic_reset || capture_dr || shift_dr) &&
	     latch_ir == 5'd17 ;

  // register dba_tdo
  assign dba_tdo$D_IN = dba[0] ;
  assign dba_tdo$EN = 1'd1 ;

  // register debug_op
  assign debug_op$D_IN = 1'b0 ;
  assign debug_op$EN = 1'b0 ;

  // register debug_select
  assign debug_select$D_IN = 1'b0 ;
  assign debug_select$EN = 1'b0 ;

  // register dtm_control
  assign dtm_control$D_IN =
	     shift_dr ?
	       temp_dtm___1__h7115 :
	       (capture_dr ? latch_dtm_control : 32'd0) ;
  assign dtm_control$EN =
	     (test_logic_reset || capture_dr || shift_dr) &&
	     latch_ir == 5'd16 ;

  // register dtm_control_tdo
  assign dtm_control_tdo$D_IN = dtm_control[0] ;
  assign dtm_control_tdo$EN = 1'd1 ;

  // register exit1_dr
  assign exit1_dr$D_IN = MUX_exit1_dr$write_1__SEL_1 ;
  assign exit1_dr$EN = (shift_dr || capture_dr) && tms || exit1_dr ;

  // register exit1_ir
  assign exit1_ir$D_IN = MUX_exit1_ir$write_1__SEL_1 ;
  assign exit1_ir$EN = shift_ir && tms || exit1_ir ;

  // register exit2_dr
  assign exit2_dr$D_IN = MUX_exit2_dr$write_1__SEL_1 ;
  assign exit2_dr$EN = pause_dr && tms || exit2_dr ;

  // register exit2_ir
  assign exit2_ir$D_IN = MUX_exit2_ir$write_1__SEL_1 ;
  assign exit2_ir$EN = (pause_ir || capture_ir) && tms || exit2_ir ;

  // register extest_select
  assign extest_select$D_IN = 1'b0 ;
  assign extest_select$EN = 1'b0 ;

  // register idcode
  assign idcode$D_IN =
	     shift_dr ?
	       temp_idcode___1__h7292 :
	       (capture_dr ? latch_idcode : 32'd0) ;
  assign idcode$EN =
	     (test_logic_reset || capture_dr || shift_dr) &&
	     latch_ir == 5'd1 ;

  // register idcode_select
  assign idcode_select$D_IN = 1'b0 ;
  assign idcode_select$EN = 1'b0 ;

  // register idcode_tdo
  assign idcode_tdo$D_IN = idcode[0] ;
  assign idcode_tdo$EN = 1'd1 ;

  // register instr_tdo
  assign instr_tdo$D_IN = instruction[0] ;
  assign instr_tdo$EN = 1'd1 ;

  // register instruction
  assign instruction$D_IN =
	     shift_ir ? temp___1__h6801 : (capture_ir ? 5'b10101 : 5'd0) ;
  assign instruction$EN = test_logic_reset || capture_ir || shift_ir ;

  // register latch_bypass
  assign latch_bypass$D_IN = bypass ;
  assign latch_bypass$EN = update_dr && latch_ir == 5'd31 ;

  // register latch_dba
  assign latch_dba$D_IN = dba ;
  assign latch_dba$EN = update_dr && latch_ir == 5'd17 ;

  // register latch_dtm_control
  assign latch_dtm_control$D_IN = dtm_control ;
  assign latch_dtm_control$EN = update_dr && latch_ir == 5'd16 ;

  // register latch_idcode
  assign latch_idcode$D_IN = idcode ;
  assign latch_idcode$EN = update_dr && latch_ir == 5'd1 ;

  // register latch_ir
  assign latch_ir$D_IN =
	     update_ir ? instruction : (test_logic_reset ? 5'd10 : 5'd0) ;
  assign latch_ir$EN = test_logic_reset || update_ir ;

  // register latch_ir_neg
  assign latch_ir_neg$D_IN = 5'h0 ;
  assign latch_ir_neg$EN = 1'b0 ;

  // register pause_dr
  assign pause_dr$D_IN = !MUX_exit2_dr$write_1__SEL_1 ;
  assign pause_dr$EN = pause_dr && tms || exit1_dr && !tms ;

  // register pause_ir
  assign pause_ir$D_IN = !MUX_pause_ir$write_1__SEL_1 ;
  assign pause_ir$EN = pause_ir && tms || exit1_ir && !tms ;

  // register run_test_idle
  assign run_test_idle$D_IN = !MUX_run_test_idle$write_1__SEL_1 ;
  assign run_test_idle$EN =
	     run_test_idle && tms ||
	     (update_ir || update_dr || test_logic_reset) && !tms ;

  // register sample_preload_select
  assign sample_preload_select$D_IN = 1'b0 ;
  assign sample_preload_select$EN = 1'b0 ;

  // register scan_chain_op
  assign scan_chain_op$D_IN = 1'b0 ;
  assign scan_chain_op$EN = 1'b0 ;

  // register select_dr_scan
  assign select_dr_scan$D_IN = MUX_select_dr_scan$write_1__SEL_1 ;
  assign select_dr_scan$EN =
	     (update_ir || update_dr || run_test_idle) && tms ||
	     select_dr_scan ;

  // register select_ir_scan
  assign select_ir_scan$D_IN = MUX_select_ir_scan$write_1__SEL_1 ;
  assign select_ir_scan$EN = select_dr_scan && tms || select_ir_scan ;

  // register shift_dr
  assign shift_dr$D_IN = !MUX_shift_dr$write_1__SEL_1 ;
  assign shift_dr$EN = shift_dr && tms || (exit2_dr || capture_dr) && !tms ;

  // register shift_ir
  assign shift_ir$D_IN = !MUX_exit1_ir$write_1__SEL_1 ;
  assign shift_ir$EN = shift_ir && tms || (exit2_ir || capture_ir) && !tms ;

  // register shift_ir_neg
  assign shift_ir_neg$D_IN = 1'b0 ;
  assign shift_ir_neg$EN = 1'b0 ;

  // register tdi
  assign tdi$D_IN = tdi_vec[count_tdi[3:0]] ;
  assign tdi$EN = shift_dr || shift_ir ;

  // register tdi_vec
  assign tdi_vec$D_IN = 9'h0 ;
  assign tdi_vec$EN = 1'b0 ;

  // register tdo
  always@(latch_ir or bypass_tdo or idcode_tdo or dtm_control_tdo or dba_tdo)
  begin
    case (latch_ir)
      5'd1: tdo$D_IN = idcode_tdo;
      5'd16: tdo$D_IN = dtm_control_tdo;
      5'd17: tdo$D_IN = dba_tdo;
      default: tdo$D_IN = bypass_tdo;
    endcase
  end
  assign tdo$EN = CAN_FIRE_RL_rl_assign_op ;

  // register tdo_enable
  assign tdo_enable$D_IN = 1'b0 ;
  assign tdo_enable$EN = 1'b0 ;

  // register test_logic_reset
  assign test_logic_reset$D_IN = MUX_test_logic_reset$write_1__SEL_1 ;
  assign test_logic_reset$EN =
	     select_ir_scan && tms || test_logic_reset && !tms ;

  // register tms
  assign tms$D_IN = tms_vec[count_tms] ;
  assign tms$EN = CAN_FIRE_RL_rl_tp ;

  // register tms_vec
  assign tms_vec$D_IN = 21'h0 ;
  assign tms_vec$EN = 1'b0 ;

  // register update_dr
  assign update_dr$D_IN = MUX_update_dr$write_1__SEL_1 ;
  assign update_dr$EN = (exit2_dr || exit1_dr) && tms || update_dr ;

  // register update_ir
  assign update_ir$D_IN = MUX_update_ir$write_1__SEL_1 ;
  assign update_ir$EN = (exit2_ir || exit1_ir) && tms || update_ir ;

  // remaining internal signals
  assign temp___1__h6801 = { tdi, instruction[4:1] } ;
  assign temp_dba___1__h6994 = { tdi, dba[40:1] } ;
  assign temp_dtm___1__h7115 = { tdi, dtm_control[31:1] } ;
  assign temp_idcode___1__h7292 = { tdi, idcode[31:1] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        bypass <= `BSV_ASSIGNMENT_DELAY 1'd0;
	bypass_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	capture_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	capture_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	count_tdi <= `BSV_ASSIGNMENT_DELAY 5'd0;
	count_tms <= `BSV_ASSIGNMENT_DELAY 5'd0;
	dba <= `BSV_ASSIGNMENT_DELAY 41'd0;
	debug_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	dtm_control <= `BSV_ASSIGNMENT_DELAY 32'd0;
	exit1_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	exit1_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	exit2_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	exit2_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	extest_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	idcode <= `BSV_ASSIGNMENT_DELAY 32'd0;
	idcode_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	instruction <= `BSV_ASSIGNMENT_DELAY 5'd0;
	pause_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pause_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	run_test_idle <= `BSV_ASSIGNMENT_DELAY 1'd0;
	sample_preload_select <= `BSV_ASSIGNMENT_DELAY 1'd0;
	select_dr_scan <= `BSV_ASSIGNMENT_DELAY 1'd0;
	select_ir_scan <= `BSV_ASSIGNMENT_DELAY 1'd0;
	shift_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	shift_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tdi <= `BSV_ASSIGNMENT_DELAY 1'd1;
	tdi_vec <= `BSV_ASSIGNMENT_DELAY 9'b000101000;
	test_logic_reset <= `BSV_ASSIGNMENT_DELAY 1'd1;
	tms_vec <= `BSV_ASSIGNMENT_DELAY 21'b011000000111000000110;
	update_dr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	update_ir <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (bypass$EN) bypass <= `BSV_ASSIGNMENT_DELAY bypass$D_IN;
	if (bypass_select$EN)
	  bypass_select <= `BSV_ASSIGNMENT_DELAY bypass_select$D_IN;
	if (capture_dr$EN)
	  capture_dr <= `BSV_ASSIGNMENT_DELAY capture_dr$D_IN;
	if (capture_ir$EN)
	  capture_ir <= `BSV_ASSIGNMENT_DELAY capture_ir$D_IN;
	if (count_tdi$EN) count_tdi <= `BSV_ASSIGNMENT_DELAY count_tdi$D_IN;
	if (count_tms$EN) count_tms <= `BSV_ASSIGNMENT_DELAY count_tms$D_IN;
	if (dba$EN) dba <= `BSV_ASSIGNMENT_DELAY dba$D_IN;
	if (debug_select$EN)
	  debug_select <= `BSV_ASSIGNMENT_DELAY debug_select$D_IN;
	if (dtm_control$EN)
	  dtm_control <= `BSV_ASSIGNMENT_DELAY dtm_control$D_IN;
	if (exit1_dr$EN) exit1_dr <= `BSV_ASSIGNMENT_DELAY exit1_dr$D_IN;
	if (exit1_ir$EN) exit1_ir <= `BSV_ASSIGNMENT_DELAY exit1_ir$D_IN;
	if (exit2_dr$EN) exit2_dr <= `BSV_ASSIGNMENT_DELAY exit2_dr$D_IN;
	if (exit2_ir$EN) exit2_ir <= `BSV_ASSIGNMENT_DELAY exit2_ir$D_IN;
	if (extest_select$EN)
	  extest_select <= `BSV_ASSIGNMENT_DELAY extest_select$D_IN;
	if (idcode$EN) idcode <= `BSV_ASSIGNMENT_DELAY idcode$D_IN;
	if (idcode_select$EN)
	  idcode_select <= `BSV_ASSIGNMENT_DELAY idcode_select$D_IN;
	if (instruction$EN)
	  instruction <= `BSV_ASSIGNMENT_DELAY instruction$D_IN;
	if (pause_dr$EN) pause_dr <= `BSV_ASSIGNMENT_DELAY pause_dr$D_IN;
	if (pause_ir$EN) pause_ir <= `BSV_ASSIGNMENT_DELAY pause_ir$D_IN;
	if (run_test_idle$EN)
	  run_test_idle <= `BSV_ASSIGNMENT_DELAY run_test_idle$D_IN;
	if (sample_preload_select$EN)
	  sample_preload_select <= `BSV_ASSIGNMENT_DELAY
	      sample_preload_select$D_IN;
	if (select_dr_scan$EN)
	  select_dr_scan <= `BSV_ASSIGNMENT_DELAY select_dr_scan$D_IN;
	if (select_ir_scan$EN)
	  select_ir_scan <= `BSV_ASSIGNMENT_DELAY select_ir_scan$D_IN;
	if (shift_dr$EN) shift_dr <= `BSV_ASSIGNMENT_DELAY shift_dr$D_IN;
	if (shift_ir$EN) shift_ir <= `BSV_ASSIGNMENT_DELAY shift_ir$D_IN;
	if (tdi$EN) tdi <= `BSV_ASSIGNMENT_DELAY tdi$D_IN;
	if (tdi_vec$EN) tdi_vec <= `BSV_ASSIGNMENT_DELAY tdi_vec$D_IN;
	if (test_logic_reset$EN)
	  test_logic_reset <= `BSV_ASSIGNMENT_DELAY test_logic_reset$D_IN;
	if (tms_vec$EN) tms_vec <= `BSV_ASSIGNMENT_DELAY tms_vec$D_IN;
	if (update_dr$EN) update_dr <= `BSV_ASSIGNMENT_DELAY update_dr$D_IN;
	if (update_ir$EN) update_ir <= `BSV_ASSIGNMENT_DELAY update_ir$D_IN;
      end
    if (debug_op$EN) debug_op <= `BSV_ASSIGNMENT_DELAY debug_op$D_IN;
    if (scan_chain_op$EN)
      scan_chain_op <= `BSV_ASSIGNMENT_DELAY scan_chain_op$D_IN;
    if (tdo_enable$EN) tdo_enable <= `BSV_ASSIGNMENT_DELAY tdo_enable$D_IN;
  end

  always@(posedge inverted$CLK_OUT)
  begin
    if (bypass_tdo$EN) bypass_tdo <= `BSV_ASSIGNMENT_DELAY bypass_tdo$D_IN;
    if (dba_tdo$EN) dba_tdo <= `BSV_ASSIGNMENT_DELAY dba_tdo$D_IN;
    if (dtm_control_tdo$EN)
      dtm_control_tdo <= `BSV_ASSIGNMENT_DELAY dtm_control_tdo$D_IN;
    if (idcode_tdo$EN) idcode_tdo <= `BSV_ASSIGNMENT_DELAY idcode_tdo$D_IN;
    if (instr_tdo$EN) instr_tdo <= `BSV_ASSIGNMENT_DELAY instr_tdo$D_IN;
    if (latch_bypass$EN)
      latch_bypass <= `BSV_ASSIGNMENT_DELAY latch_bypass$D_IN;
    if (latch_dba$EN) latch_dba <= `BSV_ASSIGNMENT_DELAY latch_dba$D_IN;
    if (latch_dtm_control$EN)
      latch_dtm_control <= `BSV_ASSIGNMENT_DELAY latch_dtm_control$D_IN;
    if (latch_idcode$EN)
      latch_idcode <= `BSV_ASSIGNMENT_DELAY latch_idcode$D_IN;
    if (latch_ir$EN) latch_ir <= `BSV_ASSIGNMENT_DELAY latch_ir$D_IN;
    if (latch_ir_neg$EN)
      latch_ir_neg <= `BSV_ASSIGNMENT_DELAY latch_ir_neg$D_IN;
    if (shift_ir_neg$EN)
      shift_ir_neg <= `BSV_ASSIGNMENT_DELAY shift_ir_neg$D_IN;
    if (tdo$EN) tdo <= `BSV_ASSIGNMENT_DELAY tdo$D_IN;
    if (tms$EN) tms <= `BSV_ASSIGNMENT_DELAY tms$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bypass = 1'h0;
    bypass_select = 1'h0;
    bypass_tdo = 1'h0;
    capture_dr = 1'h0;
    capture_ir = 1'h0;
    count_tdi = 5'h0A;
    count_tms = 5'h0A;
    dba = 41'h0AAAAAAAAAA;
    dba_tdo = 1'h0;
    debug_op = 1'h0;
    debug_select = 1'h0;
    dtm_control = 32'hAAAAAAAA;
    dtm_control_tdo = 1'h0;
    exit1_dr = 1'h0;
    exit1_ir = 1'h0;
    exit2_dr = 1'h0;
    exit2_ir = 1'h0;
    extest_select = 1'h0;
    idcode = 32'hAAAAAAAA;
    idcode_select = 1'h0;
    idcode_tdo = 1'h0;
    instr_tdo = 1'h0;
    instruction = 5'h0A;
    latch_bypass = 1'h0;
    latch_dba = 41'h0AAAAAAAAAA;
    latch_dtm_control = 32'hAAAAAAAA;
    latch_idcode = 32'hAAAAAAAA;
    latch_ir = 5'h0A;
    latch_ir_neg = 5'h0A;
    pause_dr = 1'h0;
    pause_ir = 1'h0;
    run_test_idle = 1'h0;
    sample_preload_select = 1'h0;
    scan_chain_op = 1'h0;
    select_dr_scan = 1'h0;
    select_ir_scan = 1'h0;
    shift_dr = 1'h0;
    shift_ir = 1'h0;
    shift_ir_neg = 1'h0;
    tdi = 1'h0;
    tdi_vec = 9'h0AA;
    tdo = 1'h0;
    tdo_enable = 1'h0;
    test_logic_reset = 1'h0;
    tms = 1'h0;
    tms_vec = 21'h0AAAAA;
    update_dr = 1'h0;
    update_ir = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      $display("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
	       test_logic_reset,
	       run_test_idle,
	       select_dr_scan,
	       select_ir_scan,
	       capture_dr,
	       capture_ir,
	       shift_dr,
	       shift_ir,
	       exit1_dr,
	       exit1_ir,
	       pause_dr,
	       pause_ir,
	       exit2_dr,
	       exit2_ir,
	       update_dr,
	       update_ir);
    if (RST_N != `BSV_RESET_VALUE)
      $display("%d %d %d %d %d",
	       instruction,
	       latch_ir,
	       bypass,
	       dba,
	       dtm_control);
    if (RST_N != `BSV_RESET_VALUE) $display("%d %d", count_tdi, tms);
    if (RST_N != `BSV_RESET_VALUE) $display("%d", tdo);
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_rl_stop) $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (update_dr && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 185: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_15] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit2_dr && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 173: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_14] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit2_dr && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 173: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_14] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && select_ir_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_4] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && select_dr_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_3] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (test_logic_reset && run_test_idle)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_1] and\n  [RL_rl_state_2] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && select_ir_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_4] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (run_test_idle && select_dr_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 37: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_2] and\n  [RL_rl_state_3] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_dr_scan && select_ir_scan)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 48: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_3] and\n  [RL_rl_state_4] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (select_ir_scan && capture_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 59: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_4] and\n  [RL_rl_state_5] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_dr && capture_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 70: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_5] and\n  [RL_rl_state_6] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (capture_ir && shift_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 81: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_6] and\n  [RL_rl_state_7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_ir && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 103: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_8] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && exit1_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (shift_dr && shift_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 92: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_7] and\n  [RL_rl_state_8] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_dr && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_9] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_dr && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_9] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_dr && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_9] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_dr && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_9] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_dr && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_9] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_dr && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_9] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_dr && exit1_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 114: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_9] and\n  [RL_rl_state_10] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_ir && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_10] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_ir && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_10] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_ir && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_10] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_ir && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_10] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_ir && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_10] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit1_ir && pause_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 125: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_10] and\n  [RL_rl_state_11] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_dr && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_11] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_dr && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_11] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_dr && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_11] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_dr && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_11] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_dr && pause_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 137: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_11] and\n  [RL_rl_state_12] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_ir && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_12] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_ir && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_12] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_ir && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_12] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (pause_ir && exit2_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 149: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_12] and\n  [RL_rl_state_13] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit2_ir && update_ir)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 161: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_13] and\n  [RL_rl_state_16] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit2_ir && update_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 161: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_13] and\n  [RL_rl_state_15] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (exit2_ir && exit2_dr)
	$display("Error: \"../JTAG/src_BSV/Jtag.bsv\", line 114, column 161: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rl_state_13] and\n  [RL_rl_state_14] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkJtag

